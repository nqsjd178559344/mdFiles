1. 数组 插入删除O(n)， 查找O(1)，支持随机访问
2. 链表 插入删除O(1)，查找O(n)
3. 散列表(平均情况)  插入删除O(1)， 查找O(1)
4. 散列表(最遭情况)  插入删除O(n)， 查找O(n)
最遭情况，就是要避免冲突，所以要具有：
  1. 较低的填装因子(散列表包含的元素数➗位置总数)
  2. 良好的散列函数
5. 广度优先搜索BFS(适用于非加权图)：查找芒果经销商
  1. 采用队列来存储，先弹出最前面的一个进行判断，如果不成则将其子条件压入。
  2. 判断前需要先判定是否存在过，否则容易死循环
6. 迪克斯特拉算法(适用于加权图)：乐谱换钢琴，只适用于有向非循环图，且不能有负边
    1. 在未处理的节点列表中找出花费最小的那个
    2. 遍历当前节点的所有邻居
    3.  如果当前节点前往该邻居的花费更小，则更新当前邻居的开销，且将该邻居的父节点设置为当前节点
   4. 标记当前节点为已完成
   5. 1-4🔁
7. 贪婪算法：每一步都选择最优解，具体做法：在条件未全满足的情况下，遍历所有可能解，找出最优的那个，添加进返回值数组

    NP完全问题：一般涉及到“所有组合” 或者不能将问题分成小问题，必须考虑各种可能的情况等，或者问题涉及序列(旅行商问题)或者集合(广播台集合)且难以解决

8. 动态规划：从小问题着手，逐步解决大问题(列网格)【小偷装背包问题】

    前提：每个子问题都是离散的，即不互相依赖

    小偷装背包公式：cell[i][j] ＝ max(cell[i-1][j],当前商品重量 + cell[i-1][j-当前商品重量]（剩余空间最大价值）)

    最长公共子串公式：
    如果 a[i]＝＝b[j]
    cell[i][j]＝cell[i-1][j-1]+1
    否则 cell[i][j]＝0

    最长公共子序列公式：
    如果 a[i]＝＝b[j]
    cell[i][j]＝cell[i-1][j-1]+1
    否则 cell[i][j]＝max(cell[i-1][j],cell[i][j-1])

    git diff原理为动态规划

O(1)： 常量时间，即不管多大，时间均相同