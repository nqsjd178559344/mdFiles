1. React理念 => **快速响应**
   1. 决定因素
      1. 当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。 => CPU瓶颈
         1. 解决方式 => 时间切片 => **同步更新转为可中断的异步更新**
      2. 发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。 => IO瓶颈
         1. 解决方式 => 尽可能无感知: Suspense功能及配套的hook——useDeferredValue => **同步更新转为可中断的异步更新**

2. V15为什么不满足快速响应而被重构?
   1. V15架构:
      1. 协调器(*Reconciler*) => **负责找出变化的组件**
         1. 更新时操作
            1. 调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM
            2. 将虚拟DOM和上次更新时的虚拟DOM对比
            3. 通过对比找出本次更新中变化的虚拟DOM
            4. 通知渲染器将变化的虚拟DOM渲染到页面上
      2. 渲染器(*Renderer*) => **负责将变化的组件渲染到页面上**
         1. 种类
            1. ReactDOM => 浏览器环境渲染
            2. ReactNative => APP原生组件
            3. ReactTest => 渲染出纯js对象用于测试
            4. ReactArt => 渲染到Canvas | SVG | VML(IE8)
         2. 操作 => 在每次更新发生时，渲染器接到协调器通知，将变化的组件渲染在当前宿主环境。
   2. 缺点:
      1. 协调器阶段时, mount组件会调用mountComponent, update组件会调用updateComponent => *二者均递归更新子组件*
      2. 递归更新的缺点:
         1. 无法中断，层级很深时，时间会超过16ms， 用户交互卡顿
         2. 如实现中断更新，则可能发生视图错误
3. V16如何实现支持异步更新?
   1. V16架构
      1. 调度器(*Scheduler*) => **调度任务的优先级，高优任务优先进入协调器** (requestIdleCallback's polyfill)
         1. 实现 => 浏览器有空闲时间通知
            1. 为什么不用 *requestIdleCallback*?
               1. 浏览器兼容性
               2. 触发频率不稳定, 受很多因素影响
            2. Scheduler 优点? 
               1. 除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。
      2. 协调器(*Reconciler*)
         1. 更改=> 从递归变为可中断的循环过程, 每次循环都会调用 *shouldYield* 判断当前是否有剩余时间
      3. 渲染器(*Renderer*)
   2. 如何解决中断更新时dom渲染不完全?
      1. 协调器 / 渲染器 不再交互工作
         1. 当调度器将任务交给 协调器 时, 协调器会为变化的虚拟dom打上标记(增删改)
         2. 调度器 / 协调器工作均发生于**内存**中, 只有当所有组件均完成 协调器 的工作, 才会统一交给 渲染器 => 故反复中断也不会被用户觉察
   3. ![例子](https://react.iamkasong.com/img/process.png)
      1. 红框中可能因为什么原因被中断?
         1. 有更高优先级的任务需要先更新
         2. 当前帧无剩余时间
   