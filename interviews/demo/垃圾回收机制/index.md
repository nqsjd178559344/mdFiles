# 优化的意义
   1. 因为JS单线程机制, 回收阶段浏览器一直处于等待状态, 如果进行垃圾回收则会失去对用户的响应或动画卡顿掉帧, 严重影响内存性能。
   2. 如果内存使用过高,垃圾回收的过程更缓慢, 也会导致主线程的等待时间越长, 浏览器也就越长时间得不到响应。
   3. 
#  V8的操作: 
   1. 查看: node --v8-options
   2. 设置:
      ```
      // 设置新生代内存中单个半空间的内存最小值，单位MB
      node --min-semi-space-size=1024 index.js

      // 设置新生代内存中单个半空间的内存最大值，单位MB
      node --max-semi-space-size=1024 index.js

      // 设置老生代内存最大值，单位MB
      node --max-old-space-size=2048 index.js
      ```
   
# V8的内存限制: 
   1. 新生代
      1. 32位系统: 16MB
      2. 64位系统: 32MB
   2. 老生代
      1. 32位系统: 
      2. 64位系统


# V8的内存结构

   1. 新生代[小且频繁]
      1. From
      2. To
   2. 老生代
      1. 老生代指针区
      2. 老生代数据区
   3. 大对象区: 不操作
   4. 代码区: 唯一拥有执行权限的内存区域
   5. map区:存放Map, 结构简单

#### 垃圾回收机制主要发生在哪里?

   新生代[1] + 老生代[2]
   [1]. 算法:Scavenge => 两个区域: From + To , 首先放入 From , 主线程任务完成后进入垃圾回收阶段时, 判断当前From区是否仍处于活跃状态, 如果是则将其复制,放入To区; 将From区清空; 然后进行 From区 To区交换
   [2]. 算法:标记清除+标记整理
      1. 标记清除: 
      2. 标记整理: 标记清除基础上进行整理 => 
      3. 引用计数[2012年后的浏览器均已淘汰]: 淘汰原因: 如循环引用则会被垃圾回收机制过滤
##### 新生代怎样升级为老生代?
   如一个对象经过多次的复制后仍然为活跃[基本只1次] || 当前新生代To区的内存比已使用25%时, 下次复制将新生代[晋升]为老生代,而不是移入To区

