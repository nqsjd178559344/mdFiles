## 切记

1. 考虑无网络时操作的影响
2. 考虑不同 显示屏下 的影响[兼容可视化]
3. 如果 某页面 的某部分 UI 的 UI 布局类似，但是 显示内容 及 内在逻辑 及 内在逻辑的类型 不同，则要拆出公共的显示组件，逻辑请在不同的组件中处理

   1. ts 类型定义复杂
   2. 逻辑混杂糅合,不直观

   ```tsx
   interface BaseOverviewInfo {
     title: string;
     unit?: string;
   }
   type GetDistributionDetail = (model?: OverviewModel) => string | undefined;
   type GetDurationDetail = (detail: OverviewModel["duration"]) => string;
   type GetStepDetail = (detail: OverviewModel["step"]) => string;
   type GetRecallDetail = (model?: OverviewModel) => string | undefined;
   interface DistributionOverviewInfo extends BaseOverviewInfo {
     key: "distribution";
     footer: GetDistributionDetail;
     getNumberKey?: GetDistributionDetail;
   }
   interface DurationOverviewInfo extends BaseOverviewInfo {
     key: "duration";
     footer: GetDurationDetail;
     getNumberKey?: GetDurationDetail;
   }
   interface StepOverviewInfo extends BaseOverviewInfo {
     key: "step";
     footer: GetStepDetail;
     getNumberKey?: GetStepDetail;
   }
   interface RecallOverviewInfo extends BaseOverviewInfo {
     key: "recall";
     footer: GetRecallDetail;
     getNumberKey?: GetRecallDetail;
   }
   type OverviewsInfo =
     | DistributionOverviewInfo
     | DurationOverviewInfo
     | StepOverviewInfo
     | RecallOverviewInfo;

   const overviewsInfo: OverviewsInfo[] = [
     {
       title: "案例数量",
       key: "distribution",
       footer: (model?: OverviewModel) =>
         model?.totalCases
           ? `${toDateTimeFormat(model?.distribution?.startTime) ?? ""} - ${
               toDateTimeFormat(model?.distribution?.endTime) ?? ""
             }`
           : undefined,
     },
     {
       title: "平均耗时",
       key: "duration",
       footer: (detail?: OverviewModel["duration"]) =>
         detail?.max ? `最长耗时 ${formatSeconds(detail?.max) ?? ""}` : "",
       getNumberKey: (detail: OverviewModel["duration"]) =>
         `${formatSeconds(detail.average)}`,
     },
     {
       title: "平均步骤",
       key: "step",
       footer: (detail: OverviewModel["step"]) => `最长 ${detail.max ?? ""} 步`,
       getNumberKey: (detail: OverviewModel["step"]) =>
         `${detail.average?.toFixed(2) ?? ""}`,
       unit: "步",
     },
     {
       title: "返工率",
       key: "recall",
       footer: (model?: OverviewModel) =>
         `最多返工 ${model?.recall?.max ?? ""} 次`,
       getNumberKey: (model?: OverviewModel) =>
         model?.totalCases
           ? `${((1 - model?.recall?.rate) * 100)?.toFixed(3) ?? ""}`
           : undefined,
       unit: "%",
     },
   ];

   const getDataDetail = useCallback(
     (item: OverviewsInfo, model?: OverviewModel) => {
       if (model) {
         let number, footerRender;
         switch (item.key) {
           case "distribution":
             number = item.getNumberKey
               ? item.getNumberKey(model)
               : model?.totalCases;
             footerRender = item.footer?.(model) ?? "";
             break;
           case "duration":
             number = item.getNumberKey
               ? item.getNumberKey(model.duration)
               : model?.totalCases;
             footerRender = item.footer?.(model.duration) ?? "";
             break;
           case "step":
             number = item.getNumberKey
               ? item.getNumberKey(model.step)
               : model?.totalCases;
             footerRender = item.footer?.(model.step) ?? "";
             break;
           case "recall":
             number = item.getNumberKey
               ? item.getNumberKey(model)
               : model?.totalCases;
             footerRender = item.footer?.(model) ?? "";
             break;
         }
         return (
           <div className="flex-1">
             <span className="text-sm text-[#515a6b]">
               {item.title.replace("案例", processName)}
             </span>
             <div className="text-xl font-bold text-[#162339]">
               {number !== undefined ? `${number} ${item.unit ?? ""}` : "无"}
             </div>
             <span className="text-xs text-[#7f8692] block">
               {footerRender}
             </span>
           </div>
         );
       }

       return;
     },
     [processName]
   );

   return (
     <div className="flex bg-white py-3 h-[90px]">
       {overviewsInfo.map((item) => (
         <div
           key={item.title}
           className={clx(
             "flex flex-1 pl-6 before:w-[42px] before:h-[42px] before:mr-4 before:mt-1  before:bg-no-repeat",
             {
               ['before:bg-[url("/images/mining/overview/count.svg")]']:
                 item.title === "案例数量",
               ['before:bg-[url("/images/mining/overview/duration.svg")]']:
                 item.title === "平均耗时",
               ['before:bg-[url("/images/mining/overview/variant.svg")]']:
                 item.title === "平均步骤",
               ['before:bg-[url("/images/mining/overview/rework.svg")]']:
                 item.title === "返工率",
             }
           )}
         >
           {getDataDetail(item, model)}
         </div>
       ))}
     </div>
   );
   ```

   改为

   ```tsx
   <div className="flex bg-white py-3 h-[90px]">
     <OverviewCaseCountCard />
     <OverviewDurationCard />
     <OverviewStepCard />
     <OverviewRecallCard />
   </div>;
   // 其中 上述4个组件 为逻辑处理专用组件:
   // OverviewCaseCountCard
   const { model, loading } = useOverviewsModel(id);
   const desc = useMemo(() => {
     return model?.totalCases
       ? `${toDateTimeFormat(model?.distribution?.startTime) ?? ""} - ${
           toDateTimeFormat(model?.distribution?.endTime) ?? ""
         }`
       : "";
   }, [
     model?.distribution?.endTime,
     model?.distribution?.startTime,
     model?.totalCases,
   ]);
   const processName = useProcessName();
   const title = useMemo(() => {
     return (processName ?? "案例") + "数量";
   }, [processName]);
   return (
     <OverviewCard
       title={title}
       count={loading ? "" : model?.totalCases}
       desc={desc}
       className="before:bg-[url('/images/mining/overview/count.svg')]"
     />
   );

   // OverviewCard:
   const OverviewCard = React.memo<{
     title?: string;
     count?: string | number;
     desc?: ReactNode;
     className?: string;
   }>(function OverviewCard({ title, count, desc, className }) {
     return (
       <div
         className={clx(
           "flex flex-1 pl-6 before:w-[42px] before:h-[42px] before:mr-4 before:mt-1  before:bg-no-repeat",
           className
         )}
       >
         <div className="flex-1">
           <span className="text-sm text-[#515a6b]">{title}</span>
           <div className="text-xl font-bold text-[#162339]">
             {count ?? "无"}
           </div>
           <div className="text-xs text-[#7f8692] block">{desc}</div>
         </div>
       </div>
     );
   });
   ```

4. 尽量做单页应用[不要因为某功能而跳转到新的 tab,尽量将当前 tab 直接跳转过去]
   因为可能会有用户在新 tab 操作后，直接切回旧 tab，然后就想用 新 tab 的功能！
5. 关注 组件库[如 tailwindcss 等]的新版本，及了解并使用新功能
6. [约定式提交规范](https://www.conventionalcommits.org/zh-hans/v1.0.0/)
7. Edge 扩展程序 在 C:\Users\用户名\AppData\Local\Microsoft\Edge\User Data\Default\Extensions 中
8. 引用错误: ctrl + g 清空后输入>reload 重新装载
9. [查看兼容性](https://caniuse.com/)
10. 增加条理性

## html

1. 查看当前 html: $0
2. [img 新属性](https://juejin.cn/post/6844903922109267976)
   1. srcset
   2. sizes

## dom

1.  event.stopPropagation 与 event.stopImmediatePropagation 的区别
    ```
    stopPropagation 阻止捕获和冒泡阶段中当前事件的进一步传播。
    stopImmediatePropagation 阻止事件冒泡并且阻止相同事件的其他侦听器被调用。
    ```
2.  isTrusted:
    公用 event 的属性
    返回一个 boolean,为 true 表明当前事件是由用户行为触发(比如说真实的鼠标点击触发一个 click 事件), 为 false 表明事件由一个脚本生成的(使用事件构造方法,比如 event.initEvent)

    ```tsx
    /*
      问题: 在页面中有 一个带pop的按钮和流程图,按钮 监听了 mousedown 事件,页面其他地方触发时候会调用 setVisible(false) 来取消按钮的pop显示;
      流程图 需要调接口 ,然后自动去 fitView ,fitView 的时候会自动调用 mousedown 事件
      解决办法: setVisible 之前判断一下
      */

    useLayoutEffect(() => {
      const fn = (e: MouseEvent) => {
        if (!e.isTrusted) return;
        setVisible(false);
      };
      // addEventListener 第三个参数 为options:{once:boolean;capture:boolean;passive:boolean} / useCapture:boolean = false
      document.addEventListener("mousedown", fn, false);
      return () => {
        document.removeEventListener("mousedown", fn, false);
      };
    }, []);
    ```

3.  [Observer](https://mp.weixin.qq.com/s/c3sYhwrunLqCRfPI9ZCzOg)

        ```tsx
        const options = {};
        const callback = function () {};
        const io = new Observer(callback, option);
        // 订阅
        io.observe(document.getElementById("root"));
        // 取消订阅
        io.unobserve();
        // 关闭
        io.disconnect();
        ```

    1.  [IntersectionObserver:监听元素可见性更改](https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API#intersection_observer_%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%94%A8%E6%B3%95)
        （eg: 组件可视区时懒加载、内容无限滚动、检测广告的曝光情况、在用户看见某个区域时执行任务或播放动画）

    eg: 仅触发可视区下的动效

    ```tsx
    // hiddenAnimate:可配置不使用动效
    const rootRef = useRef<HTMLSpanElement>(null);
    useEffect(() => {
      const target = rootRef.current;
      if (!target || hiddenAnimate) return;
      const ob = new IntersectionObserver((entries) => {
        if (!entries[0]) return;
        const { boundingClientRect } = entries[0];
        // 仅触发可视区以下的动效
        const isBelowViewport = boundingClientRect?.top > window.innerHeight;
        if (isBelowViewport) {
          target.classList.add("intersection-hidden");
        } else {
          target.classList.remove("intersection-hidden");
        }
      });
      ob.observe(target);

      return () => ob.disconnect();
    }, []);

    return (
      <span ref={rootRef}>
        <组件名 />
      </span>
    );
    ```

    2.  ResizeObserver 监听元素大小的更改
        eg: 获取页面当前高度

        ```tsx
        const rootRef = useRef<HTMLDivElement>(null)
        const [height, setHeight] = useState(defaultHeight);
        useEffect(()=>{
          const ob = new ResizeObserver(
            throttle(
              (entries) => {
                for (const item of entries) {
                  setHeight(item.contentRect.height);
                }
              },
              70,
              { trailing: true },
            ),
          );
        ob.observe(rootRef.current!);
        return () => ob.disconnect();
        },[])
        return <div ref={rootRef}>
          {此时 height 为 动态值 }
        </div>

        ```

    3.  MutationObserver 对元素的属性的修改、对它的子节点的增删改
        eg: 监听父元素 A 的 style 的属性:--font-size,并根据其变换当前组件的字体大小

        ```tsx
        export const useFontSize = () => {
          const [fontSize, setFontSize] = useState(() => {
            return document
              .getElementById("A")!
              .style.getPropertyValue("--font-size");
          });
          useEffect(() => {
            let mutationObserver: MutationObserver | undefined = undefined;
            mutationObserver = new MutationObserver(
              debounce(
                (mutationList) => {
                  const fontSize =
                    mutationList[0].target.style.getPropertyValue(
                      "--font-size"
                    );
                  setFontSize(fontSize);
                },
                200,
                { trailing: true }
              )
            );
            mutationObserver.observe(document.getElementById("A")!, {
              childList: false,
              attributes: true,
              subtree: false,
            });
            return () => {
              mutationObserver?.disconnect();
            };
          }, []);
          return fontSize;
        };

        // 使用时:
        const fontSize = useFontSize();
        const _fontSize = useDeferredValue(fontSize);
        // 判断字体是否改变
        const fontSizeChanged = useMemo(() => {
          return !isEqual(fontSize, _fontSize);
        }, [_fontSize, fontSize]);
        ```

4.  event.target 与 event.currentTarget 的区别:
    1. event.target 当前点击的元素
    2. event.currentTarget 触发的元素 例如 onClick 绑定的元素
5.  API[https://developer.mozilla.org/zh-CN/docs/Web/API/Element]

    ```tsx
    document.createElement();
    document.addEventListener();
    document.removeEventListener();
    document.contains();
    document.getSelection();
    document.elementsFromPoint();
    /*
    document.createEvent();
    document.initEvent();
    */
    document.dispatchEvent();
    ```

6.  dispatchEvent(new Event()) 与 dispatchEvent(new CustomEvent()) 的区别?

    1. 参数

    ```tsx
      dispatchEvent(new Event("resize"));
      dispatchEvent(
        new CustomEvent("mousedown", { bubbles: true, cancelable: true })
      );
    ```

    ```tsx
      getAttribute;
      closest;
      toggle;
      dataset;
      matches;
      contains;
    ```

## css

1. 取消双击选中文本样式

```css
  -moz-user-select: none; /*火狐*/
  -webkit-user-select: none; /*webkit浏览器*/
  -ms-user-select: none; /*IE10*/
  -khtml-user-select: none; /*早期浏览器*/
  user-select: none;
```

2. 在一个 flex 布局中，如下 设置 保证内容不超出外层容器 ,如果没有设置 当内容大于剩余盒子宽度/高度时会超出父盒子。

```css
  flex: 1;
  min-height: 0;
  min-width: 0;
```

3.  width: fit-content / max-content / min-content / auto 的区别
   
    ```css
      min-content:[内部最小宽度们的最大值]
        1. 均为中文时，为 1 个字的宽度
        2. 包含英文时，为最长单词的宽度
      max-content:[内部最大宽度们的最大值]
      width:-webkit-fill-available
    ```

4.  outline 的属性[与 border 类似]
   
     ```css
      偏移量: outline-offset:5px; => 距离 border
      outline-style / border-style:

      none： 默认值。定义无轮廓。
      dotted: 定义一个点状的轮廓。
      dashed: 定义一个虚线轮廓。
      solid: 定义一个实线轮廓。
      double: 定义一个双线轮廓。双线的宽度等同于 outline-width 的值。 // 内部外部均 === outline-color; 但是 中间间隔 outline-width 的距离
      groove: 定义一个 3D 凹槽轮廓。此效果取决于 outline-color 的值 // 外部 === outline-color; 内部 比 外部 深的颜色
      ridge: 定义一个 3D 凸槽轮廓。此效果取决于 outline-color 的值 // 内部 === outline-color; 外部 比 内部 深的颜色
      inset: 定义一个 3D 凹槽轮廓。此效果取决于 outline-color 的值 // 内部外部均 === outline-color;
      outset: 定义一个 3D 凸槽轮廓。此效果取决于 outline-color 的值 // 内部外部均 === 比 outline-color 深的颜色;
     ```
  
5.  gap

    column-gap / row-gap

6.  超出一行显示省略号的 css
    1. [line-clamp](https://tailwindcss.com/docs/line-clamp)
    注： 后三者配套使用
    ```css
      overflow: hidden;
      text-overflow: ellipsis; // 仅在块盒中生效
      word-wrap: break-word; 
      word-break: break-all;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: n;
      display: -webkit-box; / display: -webkit-inline-box;
    ```

    2. [truncate](https://tailwindcss.com/docs/text-overflow#truncate)

    ```css
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    ```

7. 文本折行
    
   1. [word-break](https://tailwindcss.com/docs/word-break) // 单词换行
      [兼容性情况](https://caniuse.com/?search=word-break)
      ```css
        overflow-wrap: normal; 
        word-break: normal;

        word-break: break-word; 

        word-break: break-all;

        word-break: keep-all;	
      ```
      
   2. [overflow-wrap](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-wrap)
    word-break补集，兼容性更好
   ```css
      overflow-wrap: break-word; 
   ```
   4. [white-space](https://tailwindcss.com/docs/whitespace) // 空白字符的显示
   5. [text-wrap](https://juejin.cn/post/7222919413979234359?searchId=20240306171505A322955736AA2118E641)
8.  overflow:hidden 不可限制 box-sizing: border-box 时候的 边框超出情况

    ```html
    <div style="width: 100%; height: 200px; background-color: yellow">
      <div
        style="
           width: 100%;
           height: 50px;
           max-height: 50px;
           border: 40px dashed burlywood;
           background-color: yellowgreen;
           display: flex;
           box-sizing: border-box;
           overflow: hidden; 
         "
      >
        <div
          style="
             min-height: 0;
             min-width: 0;
             align-items: center;
             background-color: pink;
           "
        >
          111
        </div>
      </div>
    </div>
    ```

9.  如何 让 子级 继承 父级的 css

    把子级 的 css 设为 inherit

10. 不使用!important 的方式去增加样式: .class.class.class
11. pointer-events
12. :has, :is, :where 区别

    1. :is

       ```css
       /* 设置 header, main, footer 里的任意一个 p 标签的 hover 状态 */
       header p:hover,
       main p:hover,
       footer p:hover {
         /* … */
       }

       /* 可以使用 :is() 简写为以下 */
       :is(header, main, footer) p:hover {
         /* … */
       }

       some-element::before,
       some-element::after {
         /* … */
       }

       /* 不能选择伪元素 */
       some-element:is(::before, ::after) {
         /* … */
       }

       /*当前部分支持的selector 会生效*/
       :is(:valid, :unsupported) {
         /* … */
       }
       ```

    2. :is :where 区别 :
          :is 优先级为 它的选择器列表中优先级最高的选择器决定的。 ，:where 优先级为 0

    3. :has

    ```css
      /* 只要 <a> 元素里面有 <img> 元素，这个 <a> 元素就会匹配：*/
      a:has(img) { /_ … _/ }
      /* 匹配直接包含 <img> 子元素的 <a> 元素 */
      a:has(> img) { /_ … _/ }
      /* 匹配其后紧跟着 <p> 元素的 <h1> 元素 */
      h1:has(+ p) { /_ … _/ }
      /*只要 <article> 元素内有 <h5> 元素或者有 <p> 元素就会匹配*/
      article:has(h5, p) { /_ … _/ }
      /* <article> 元素内同时有 <h5> 元素和 <p> 元素才匹配 */
      article:has(h5):has(p) { /_ … _/ }
    ```

13. opacity 会遗传给子元素 即:子元素实际 opacity = 父元素 opacity \* 子元素设置的 opacity
14. [clip-path](http://tools.jb51.net/code/css3path)
15. [object-fit](https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit)图片在固定宽高范围内进行剪切,保持原始比例
16. [outline](https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline)
    ```css
    border 和 outline 区别：

    outline 不占据空间，绘制于元素内容周围。
    根据规范，outline 通常是矩形，但也可以是非矩形的。
    ```
17. 默认定义在后面的样式会覆盖定义在前面的，与使用时的位置无关(位置: ./interviews/demo/css.html)


#### 兼容

1.  Firefox 浏览器如下设置时，高度将消失;

```css
.max-fill-grid {
  flex: 0 1 auto;
  height: auto;
  contain: layout style paint;
  /*
    官方定义: contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图或它们的组合的时候，只会影响到有限的 DOM 区域，而不是整个页面。
    layout style paint === content
    layout style paint size === strict
    */

  /* 设置专用 css 可解决 */
  @supports (-moz-appearance: none) {
    /*
    -moz-appearance: none: 判断当前为 Firefox 浏览器
    */
    flex-grow: 1;
  }
}
```

## tailwindcss

1. :first-child / :last-child

   ```css
   .variant {
     margin: 6px;
     &:first-child {
       margin-top: 0px;
     }
     &:last-child {
       margin-bottom: 0px;
     }
   }
   ```

使用 tailwindcss:

    ```jsx
    <div className="my-1.5 first:mt-0 last:mb-0"></div>
    ```

1. tailwindcss 如果想动态放置 background-image 则需写成:

   ```jsx
   <div
   <!-- tailwind 只能扫描 className 字符串, 如为变量则不能识别 -->
     className={classnames({
       ['before:bg-[url("/images/icon1.svg")]']: 条件1,
       ['before:bg-[url("/images/icon2.svg")]']: 条件2,
       ['before:bg-[url("/images/icon3.svg")]']: 条件3,
       ['before:bg-[url("/images/icon4.svg")]']: 条件4,
     })}
   />
   ```

2. tailwind 父级 hover 时子集变字体颜色

   ```jsx
   <div className="group peer">
      <div className="group-hover:!text-orange"></div>
   </div>
   <div className="peer-hover:!text-green"></div>
   ```

3. 改变当前元素的子元素的 css
   注意: 当前版本(3.1.4) 不可跳级选择

   ```jsx
   <div className="[&>.ant-select-selector]:min-w-0 [&>.ant-select-selector>div>.ant-select-selection-overflow-item]:bg-[yellow]"></div>
   ```

4. 如 想改变当前元素的子元素的 hover 等状态

   ```jsx
   <div className="[&_.ant-steps-item-tail]:after:!bg-[#d0d3d7]"></div>
   ```

5. 使用 rgba 时其中不可有空格

   ```jsx
   <div className="bg-[rgba(0,0,0,0.4)]"></div>
   ```

## js

1. Warning: Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop? => 先声明了 form: `const [form] = Form.useForm<当前类型>()`
   在一个暂时不存在<条件渲染>的 dom 上绑定了 form
   解决办法: 使用 forwordRef/ref 将组件拆出来,在其中绑定 form 与 父组件传入的 ref,然后继续条件渲染该组件; 当使用时,用 ref.current 取得子组件的 form, 继而进行操作

2. 同一页面 ,不可 将 model 绑定于 tab 上, 如数量不对, react 会判断为当前的 hook 存在已被卸载 / 额外新增 或 未按顺序执行, 抛出异常 => 新建个 state 去存储 当前 tab 上的的数据,保证数据源的唯一

3. 在 HTML 后缀的文件中使用 react

   1. 引入

      ```jsx

        <script
          crossorigin
          src="https://unpkg.com/react@17/umd/react.development.js">
        </script>

        <script
          crossorigin
          src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"
        ></script>

        <script src="https://unpkg.com/babel-standalone@6.26.0/babel.js"></script>

      // 目标 js 文件

        <script type="text/babel" src="index.js"></script>

      ```

   2. 在 HTML 文件中设置 <div id="root"></div>

   3. 目标 js 文件的最下面绑定 root

      ```jsx
      const domContainer = document.querySelector("#root");
      ReactDOM.render(React.createElement(组件名), domContainer);
      ```

4. padEnd / padStart [String]

    ```js
      /**
       str.padEnd/padStart(目标长度,?填充字符串)
      **/
      "abc".padStart(10) / "abc".padEnd(10); // "abc"
      "abc".padStart(10, "foo"); // "foofoofabc"
      "abc".padEnd(10, "foo"); // "abcfoofoof"
      "abc".padStart(1) / "abc".padEnd(1); // "abc"
    ```

5. 通过 iframe 将 https 的页面嵌入至 http 私有化部署的网站中, iframe 下面 cookie 会丢
   原因:"SameSite=Lax"

   1. SameSite=None + Secure [需要 https] ×
      https://zhuanlan.zhihu.com/p/257860705
      https://zhuanlan.zhihu.com/p/354215929
   2. 通过 URL 将 token 取出来并登陆

6. [页面缩放判断](https://www.zhangxinxu.com/wordpress/2021/02/js-if-page-zoom/)

7. [scrollIntoView 滚动父元素至当前元素可见](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView)
   
8. 将 string 的字符串转换为 HTML
   ```jsx
   const parser = new DOMParser();
   const doc = parser.parseFromString(html, "text/html");
   ```

9. [js如何自定义事件](https://github.com/YvetteLau/Blog/issues/20)
10. [fetch简介](https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html)
11. Array新事件
    ```js
    <!-- 允许对数组进行操作时，不改变原数组，而返回一个原数组的拷贝。 -->
    Array.prototype.toReversed() -> Array // 对应reverse()，用来颠倒数组成员的位置。
    Array.prototype.toSorted(compareFn) -> Array // 对应sort()，用来对数组成员排序。
    Array.prototype.toSpliced(start, deleteCount, ...items) -> Array // 对应splice()，用来在指定位置，删除指定数量的成员，并插入新成员。
    Array.prototype.with(index, value) -> Array // 对应splice(index, 1, value)，用来将指定位置的成员替换为新的值。
    ```

## react

1. 新 API
   startTransition / useTransition / useDeferredValue
2. useState 参数如为 函数,函数不可返回 Promise
   ```jsx
   const [state, setState] = useState(() => {
     // 不可使用 async , 不会等运行完的
     const initialState = someExpensiveComputation(props);
     return initialState;
   });
   ```
3. useDeferredValue 可进行数值对比(数值是否更改等)

## ts

1.  typescript 类型判定

    1.  ts 的类型为一起开发的人服务,要能做到编辑器自动推断
        eg:

        ```tsx
        import { LabeledValue } from "antd/lib/select";
        const option = {
          label: `${data[label]?.name ?? label}(${number})`,
          value: label,
        } as LabeledValue;
        ```

        此时 如果 程序员未 写 value, 在 value 那行写下 v, 编辑器应该给出提示

    2.  类型谓词 https://www.kelen.cc/posts/612da7024971412461d8e3ad

    3.  https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types

        ```jsx
        1.  type ToArray<Type> = Type extends any ? Type[] : never
            ToArray<string|number> = ToArray<string> | ToArray<number> = string[] | number[]

        2.  type ToArray<Type> = [Type] extends [any] ? Type[] : never
            ToArray<string|number> = (string | number)[]
        ```

    4.  https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as

2.  类型别名和接口的区别

    1. type 能够表示非对象类型，而 interface 只能表示对象类型（包括数组、函数等）。
    2. 同名 interface 会自动合并，同名 type 则会报错。（interface 是开放的，可以添加属性，type 是封闭的，不能添加属性，只能定义新的 type。）
    3. interface 不能包含属性映射（mapping），type 可以

    ```ts
        // 正确
        type PointCopy1 = {
          [Key in keyof Point]: Point[Key];
        };
        // 报错
        interface PointCopy2 {
          [Key in keyof Point]: Point[Key];
        };
        type 可以扩展原始数据类型;interface 不行。
        // 正确
        type MyStr = string & {
          type: 'new'
        };
        // 报错
        interface MyStr extends string {
          type: 'new'
        }
    ```

    4. interface 无法表达某些复杂类型（比如交叉类型和联合类型），但是 type 可以。

3.  object 和 Record<string,unknown> 的区别

    ```tsx
      object:包含对象、数组和函数
      Record<string,unknown>: 只包含对象

      {
        [property: string]: unknown
      };
    ```

4.  交叉类型

    ```tsx
      type Obj = { foo: string } & { bar: string };

      type Obj2 = {
        foo: string;
        bar: string;
      };
      在vscode中如果想让hoverObj的类型显示为Obj2, 则需对Obj进行Omit_never操作;

      Omit<Obj, never> = Obj2;
    ```

5.  只读数组

    ```tsx
      // 报错
      const arr: readonly Array<number> = [0, 1];
      // 正确
      const a1: ReadonlyArray<number> = [0, 1];
      const a2: Readonly<number[]> = [0, 1];
    ```

6.  可选参数与默认值不能同时使用
7.  implements 与 extends 的区别
8.  泛型类的类型参数写在类名后面

    ```ts
      class Pair<K, V> {
        key: K;
        value: V;
      }
    ```

9.  Enum
10. 断言函数是一种特殊函数，用于保证函数参数符合某种类型。如果函数参数达不到要求，就会抛出错误，中断程序执行；如果达到要求，就不进行任何操作，让代码按照正常流程运行。
    ```ts
    // 断言函数不返回值
    function isString(value: unknown): asserts value is string {
      if (typeof value !== "string") throw new Error("Not a string");
    }
    // 类型保护函数总是返回一个布尔值。
    function isString(value: unknown): value is string {
      return typeof value === "string";
    }
    ```
11. declare ：告诉编译器，某个类型是存在的，可以在当前文件中使用。
    ```ts
      declare global {
        interface Window {
          _settings: {
            title?: string;
          };
        }
      }
    ```
12. [tsconfig]('https://wangdoc.com/typescript/tsconfig.json')

## swr

1. swr 批量更新 某类符合条件接口 <比 setKey 后用 key 作为依赖来强制刷新好处: 数据无中间状态,即最大可能无感知操作>

   ```tsx
   import { useSWRConfig } from "swr";

   export function useMatchMutate() {
     const { cache, mutate } = useSWRConfig();
     return (matcher: RegExp, ...args: [any?, (boolean | undefined)?]) => {
       if (!(cache instanceof Map)) {
         throw new Error(
           "matchMutate requires the cache provider to be a Map instance"
         );
       }

       const keys = [];

       for (const key of cache.keys()) {
         if (matcher.test(key)) {
           keys.push(key);
         }
       }

       const mutations = keys.map((key) => {
         if (args.length) {
           return mutate(key, ...args);
         } else {
           return mutate(key);
         }
       });
       return Promise.all(mutations);
     };
   }

   export const getListSWRMutateKeyRegExp = memoize(function (params) {
     // 匹配正则
     return new RegExp(
       `${JSON.stringify(JOB_LOG_URL)}.*${JSON.stringify(params.robotId)}.*$`
     );
   });

   export const useRevalidateJobLogList = memoize(function (params) {
     const mutateWithRegExp = useMatchMutate();
     const jobLogListMutateRegExp = getListSWRMutateKeyRegExp(params);
     return () => mutateWithRegExp(jobLogListMutateRegExp);
   });
   ```

2. useSWRInfinite

   ```tsx
   const getKey = useCallback(
     (index: number) => {
       return [index, searchText, MINING_URL, id] as const;
     },
     [id, searchText]
   );

   const { data, isValidating, size, setSize } = useSWRInfinite(
     getKey,
     (page: number, searchText) => {
       return getList(id, {
         ...params,
       });
     },
     {
       revalidateFirstPage: false,
     }
   );

   // 操作
   setInterval(() => {
     setSize((p) => p + 1);
   }, 300);
   ```

## recoil

1. 使用 recoil 的 useRecoilRefresher_UNSTABLE 统一刷新时 ，如果想在纯函数中调用，不可以;如果想在事件中调用<事件中才可确定 ID>，也不可以，因为 useRecoilRefresher_UNSTABLE 为一个事件,必须在之前就绑定好一个 Refresher 事件; 故如果是一个 atomFamily/selectorFamily 时,params 不可事先绑定 => useState 存储值，后在 useLayoutEffect 中同步更新

   ```tsx
   const [targetRefreshParams, setTargetRefreshParams] =
     useState<TargetRefreshParams>({
       id: id!,
       type: null,
     });

   const refresher = useMemo(() => {
     return {
       workflow: workflowRefresh,
       mining: miningRefresh,
     };
   }, [miningRefresh, workflowRefresh]);

   const workflowRefresh = useRecoilRefresher_UNSTABLE(
     workflowAtoms(targetRefreshParams?.id)
   );
   const miningRefresh = useRecoilRefresher_UNSTABLE(
     miningAtoms(targetRefreshParams?.id)
   );

   // 操作时 部分使用 recoil 存储的数据只能用 useRecoilRefresher_UNSTABLE 来刷新
   if (newData.itemType in refresher) {
     setTargetRefreshParams({
       id: newData.itemResourceId,
       type: newData.itemType as TargetRefreshParams["type"],
     });
   }

   // 随后在 useLayoutEffect
   useLayoutEffect(() => {
     if (targetRefreshParams.type) {
       refresher?.[targetRefreshParams.type]?.();
     }
   }, [refresher, targetRefreshParams]);
   ```

2. 假设 recoil 的 selectorFamily 中依赖了 A:类型为一个数组，还有一个 B，然后这个 A 的地址改变会判断为新的数据=>[解决方式:把数组转为 string 传过去]，然后在一个事件里同步修改 B 和 A,会调用两次 selectorFamily 中绑定的接口

解决办法: AB 异步改变 / 在 设置 A 时 , 在 set 事件中去 设置 B

    ```tsx
    export const state = selectorFamily<string[] | null, string>({
      key: "state",
      get:
        (params) =>
        ({ get }) =>
          get(otherState(params)),
      set:
        (params) =>
        ({ set, reset }, newValue) => {
          set(otherState1(params), undefined);
          reset(otherState2(params));
          set(otherState(params), newValue);
        },
    });
    ```

3. key 值不变[JSON.stringify 后不变] 如果一个 selectorFamily:1 值 依赖着 另一个 selectorFamily:2 , 2 的 值的改变 会引起 1 重新请求接口 ; 故 将 2 的 值 去做 [数据先排序，再序列化为`字符串`，使其做为请求依赖可以有效利用已有缓存 :JSON.parse(JSON.stringify(value))]
4. useRecoilCallback
   1. 如果 不使用 useRecoilCallback 提供的 reset/get/set 方法，则 建议用 react 的 useCallback 方法
   2. 使用 useRecoilCallback 的 set 方法会减少页面重新渲染次数
5. reset 一个 selector 时, 会触发其 set 方法
6. recoil 的缺点
   画图像的时候，要在一个事件中动态的添加节点，添加边，均要根据算法动态计算
   recoil 无法在同一个 useRecoilCallback 中去获取每次更新后的新的 snapshot，而 jotai 能做到

## d3

1. d3 update 时渲染不对 => 在数据改变后同步刷新页面

## nextjs

1.  <Image /> 宽高优化及 srcset&size 属性
    [srcset&size 属性](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img#%E4%BD%BF%E7%94%A8_srcset_%E5%92%8C_sizes_%E5%B1%9E%E6%80%A7)
2.  react-countup 使用报错解决方式(https://github.com/glennreyes/react-countup/issues/806)(https://github.com/glennreyes/react-countup/issues/805)

    1.  版本锁定[×]
        问题: 当 正常打包 或 静态导出 时,将报错[output: "export"](https://nextjs.org/docs/pages/api-reference/next-config-js/output)

    ```json
     "resolutions": {
               "react-countup/countup.js": "2.5.0"
             },
    ```

    2.  懒加载导入[√]

        ````jsx
            const CountUp = lazy(() => import("react-countup"));
            ```
        ````

3.  添加动效 aos

5.  点击 footer 中的组件名，需要跳转到不同组件的位置（可能为不同页面）
    参数通过 URL 传递，组件都使用共同的公共组件（Title）去显示标题，在 Title 组件中传入 componentName，当两者一致时将对应组件滚动至可视区

    ```tsx
    const rootRef = useRef<HTMLDivElement | null>(null);

    useEffect(() => {
      if (query && "link" in query && typeof query["link"] === "string") {
        if (query["link"] === componentName) rootRef.current?.scrollIntoView();
      }
    }, [componentName, query]);
    ```

6.  通过接口动态获取需要显示的组件且动态导入所有组件

    ```tsx

    // 接口生成
    // Next.js API route support: https://nextjs.org/docs/api-routes/introduction
      import { DataItem } from "@/interfaces";
      import type { NextApiRequest, NextApiResponse } from "next";

      const data: DataItem[] = [
        {
          url: "/",
          title: "页面A",
          hiddenInFooter: true,
          children: [
            {
              title: "a",
              componentName: "A",
            },
            {
              title: "b",
              componentName: "B",
            },
            {
              title: "c",
              componentName: "C",
            },
            {
              title: "d",
              componentName: "D",
            },
          ],
        },
        {
          url: "/b",
          title: "页面B",
          children: [
            {
              title: "e",
              componentName: "E",
            },
            {
              title: "f",
              componentName: "F",
            },
            {
              title: "g",
              componentName: "G",
            },
          ],
        },
      ];

      export default async function handler(
        _: NextApiRequest,
        res: NextApiResponse<DataItem[]>
      ) {
        res.status(200).json(data);
      }

      type DefaultComponentParams = {
        componentName:string
      }

      // 组件库编写
      // 动态导入所有组件
      import { DefaultComponentParams } from "@/interfaces";
      import dynamic from "next/dynamic";
      import { ComponentType } from "react";

      const 组件名 = dynamic(() => import("./组件名"));

      export const componentsMap: Record<
        string,
        ComponentType<Partial<DefaultComponentParams>>
      > = {
        组件名,
        ...
      };

    // 通过接口动态获取需要显示的组件
    import { DataItem } from "@/interfaces";

    export const useComponents = function (url: string, strict?: boolean) {
      const { data } = useSWR<DataItem[]>("/api/data", fetcher);

      const children = useMemo(() => {
        return data?.find((item) =>
          strict ? item.url === url : item.url.includes(url)
        )?.children;
      }, [data, strict, url]);

      const components = useMemo(() => {
        return children?.map((item, index) => {
          const TargetControl = item.componentName
            ? componentsMap[item.componentName]
            : undefined;

          return TargetControl ? (
            <TargetControl
              {...item.componentParams}
              componentName={item.componentName}
              key={item.title ?? index}
            />
          ) : undefined;
        });
      }, [children]);

      return components;
    };
    export type DefaultComponentParams = {
      componentName?: DataItemChildrenItem["componentName"];
    };

    // 页面中
    const components = useComponents(url, true);
    ```

7.  空组件绑定 ref
8.  组件统一样式: 最大宽度 1200，超过时自动放于页面中间显示；用媒体查询自动兼容手机屏幕

    ```jsx

    // tailwind中设置
    theme:{
      extend:{
          screens: {
            sm: "640px",
            md: "768px",
            lg: "1024px",
            xl: "1200px",
            "2xl": "1440px",
          },
      }
    }

    // 使用
    <span className="xl:w-[1200px] xl:mx-auto w-full"></span>

    ```

## 其余组件库

### react-router-dom

1. useSearchParams 使用

   ```jsx
   import { useSearchParams } from "react-router-dom";

   const [searchParams, setSearchParams] = useSearchParams();
   searchParams.get(key);
   searchParams.delete(key);
   searchParams.set(key, value);
   setSearchParams(searchParams, { state });
   ```

2. Outlet 占位符
3. 如果想 路由 a 和 路由 b 同时显示同一个侧边菜单栏[状态相同] 且 不影响原有路由使用

   ```ts
   // routes.ts
   {
     path: 'apps/:appId',
     component: lazy(() => import('../layout/AppLayout/AppLayoutContent')),
     routes: [
              {
                path: '',
                component: lazy(() => import('../pages/apps/DataSetting')),
                routes: [
                  {
                    path: 'a',
                    component: lazy(() => import('../pages/apps/DataSetting/A/empty')),
                  },
                  {
                    path: 'a/:id',
                    component: lazy(() => import('../pages/apps/DataSetting/A')),
                  },
                  {
                    path: 'b/:id',
                    component: lazy(() => import('../pages/apps/DataSetting/B')),
                  },
                ],
              },
            ],
   },
   ```

   ```tsx
   // 因为 path: '' 是会默认进入的，所以 DataSetting 中要注意做路由拦截显示
   const { pathname } = useLocation();
   const { appId } = useParams() as { appId: string };
   const aUrl = `/apps/${appId}/a`;
   const bUrl = `/apps/${appId}/b`;
   if (!(pathname.startsWith(aUrl) || pathname.startsWith(bUrl))) {
     // 显示 Loading效果
     return (
       <div className="w-full h-24 flex-center">
         <Loading />
       </div>
     );
   }
   ```

### antv

1. 基本使用

   ```tsx

   import { Column } from '@antv/g2plot';

   const calculatedData = {key,value}[]

   const config = useMemo(
   () => ({
      data: calculatedData ?? [],
      xField: 'key',
      yField: 'value',
      color,
      label: {
        content: (item: any) => {
          return `${item?.value}`;
        },
      },
      meta: {
        key: {
          alias: '类别',
        },
        value: {
          alias: '数量',
        },
      },
   }),
   [calculatedData, color],
   );

   useEffect(() => {
    if (barChart.current) {
      barChart.current.update(config);
    }
   }, [barChart, config]);

   useEffect(() => {
    barChart.current = new Column(chartId, config);
    barChart.current.render();

    return () => {
      if (barChart.current) {
        barChart.current.destroy();
        barChart.current = undefined;
      }
    };
   // eslint-disable-next-line react-hooks/exhaustive-deps
   }, []);

   return  <div style={{ display: 'flex', width: '100%', height: '250px' }} id={chartId} />
   ```

2. 点击按钮时， 获取 Column 的 slider 的 当前值
   1. 方法一: 事件监听 on("slider:onmouseup") => 文档上没写，不建议使用 && 触发有些问题
   2. 用 useImperativeHandle + ref 绑定 Column 实例，点击的时候获取 (Column.chart as any).filteredData => Column.chart.filteredData 为 protected 类型

### typescript-lodash

1. extends infer

#### common

1. IsEqual

#### string

1. LastIndexOf
2. PadStart & PadEnd
3. Uppercase & Lowercase 是 ts 自带的吗
4. SubStr

### [github 文档](https://docs.github.com/cn)

### [turfjs](https://turfjs.fenxianglu.cn/category/)

### [前端工程化](https://mp.weixin.qq.com/s/pVI1pmZdNIRWguoV5HKAeg)

### 生产环境

1. 本地 message 正常, 线上 message 不弹出

```tsx
// 本地自动导入:
import message from "antd/lib/message";
// 改为
import { message } from "antd";
// 即可解决
// antd/lib/* 来导入类型是不影响的
```

### sql

      ```sql
      1. 查
        SELECT
        WHERE
        ORDER BY
        LIMIT x OFFSET y;
        COUNT、SUM、AVG、MAX、MIN
        INNER/RIGHT OUTER/LEFT OUTER/FULL OUTER JOIN ... ON 条件
        中文: ``

      2. 修改数据:

        INSERT INTO table_name (列 1, 列 2,...) VALUES (值 1, 值 2,....)
        UPDATE <表名> SET 字段 1=值 1, 字段 2=值 2, ... WHERE ...;
        DELETE FROM <表名> WHERE ...;
      ```

### svg

   1. g
   2. defs
   3. marker
   4. use

### 前端工程化工具 ![前端工程化工具](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99772dda41f841e98884551c4ac00143~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)
  1. 任务运行器 gulp等
  2. 包管理器 npm yarn pnpm
  3. 编译器 Babel tsc(TypeScript)等
  4. Customized Builder vite cra 
  5. 打包工具 webpack Rollup
    swc与ESBuild
      1. swc为更高版本的babel
      2. ESBuild为更高版本webpack
   6. html2canvas 对css部分属性(z-index, 伪元素等)缺少支持

### Babel配置
    ```json
    {
      "presets": [
        [
          "@babel/preset-env", // https://babel.dev/docs/babel-preset-env
          {
            "loose": true,
            "bugfixes": true,
            "targets": "> 2%",
            "corejs": 3,
            "useBuiltIns": "entry" // 动态垫片
          }
        ],
        "@babel/preset-typescript",
        "@babel/preset-react"
      ],
      "plugins": ["@babel/transform-runtime"] // https://babel.dev/docs/babel-plugin-transform-runtime#why
    }
    
    ```
### 其他
1. 将修改过的 csv 文档 重置回 csv 文档
   1. 下载 notepad ++
   2. 选择文件并将文件转为 utf-8 格式
   3. 重新保存设置