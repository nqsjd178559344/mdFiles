## css

1. 取消双击选中文本样式

```css
-moz-user-select: none; /*火狐*/
-webkit-user-select: none; /*webkit浏览器*/
-ms-user-select: none; /*IE10*/
-khtml-user-select: none; /*早期浏览器*/
user-select: none;
```

2. 在一个 flex 布局中，如下 设置 保证内容不超出外层容器 ,如果没有设置 当内容大于剩余盒子宽度/高度时会超出父盒子。

   ```css
   flex:1;
   min-height: 0/min-width: 0;
   ```

3. width: fit-content / max-content / min-content / auto 的区别
4. outline 的属性 [与 border 类似]
   偏移量: outline-offset:5px; => 距离 border
   outline-style / border-style:
   1. none： 默认值。定义无轮廓。
      dotted: 定义一个点状的轮廓。
      dashed: 定义一个虚线轮廓。
      solid: 定义一个实线轮廓。
      double: 定义一个双线轮廓。双线的宽度等同于 outline-width 的值。 // 内部外部均 === outline-color; 但是 中间间隔 outline-width 的距离
      groove: 定义一个 3D 凹槽轮廓。此效果取决于 outline-color 的值 // 外部 === outline-color; 内部 比 外部 深的颜色
      ridge: 定义一个 3D 凸槽轮廓。此效果取决于 outline-color 的值 // 内部 === outline-color; 外部 比 内部 深的颜色
      inset: 定义一个 3D 凹槽轮廓。此效果取决于 outline-color 的值 // 内部外部均 === outline-color;
      outset: 定义一个 3D 凸槽轮廓。此效果取决于 outline-color 的值 // 内部外部均 === 比 outline-color 深的颜色;

#### 兼容

1.  Firefox 浏览器如下设置时，高度将消失;

```css
.wrapper {
  flex: 0 1 auto;
  height: auto;
  contain: layout style paint === content;
  /*
  官方定义: contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图或它们的组合的时候，只会影响到有限的 DOM 区域，而不是整个页面。
  layout style paint === content
  layout style paint size === strict
  */

  // 设置专用 css 可解决
  @supports (-moz-appearance: none) {
    /*
    -moz-appearance: none: 判断当前为 Firefox 浏览器
    */
    flex-grow: 1;
  }
}
```

#### tailwindcss

1. tailwindcss 使用 :first-child / :last-child

```css
.variant {
  margin: 6px;
  &:first-child {
    margin-top: 0px;
  }
  &:last-child {
    margin-bottom: 0px;
  }
}
```

使用 tailwindcss:
className="my-1.5 first:mt-0 last:mb-0"

2. tailwindcss 如果想动态放置 background-image 则需写成:

```jsx
<div
  className={classnames({
    ['before:bg-[url("/images/icon1.svg")]']: 条件1,
    ['before:bg-[url("/images/icon2.svg")]']: 条件2,
    ['before:bg-[url("/images/icon3.svg")]']: 条件3,
    ['before:bg-[url("/images/icon4.svg")]']: 条件4,
  })}
></div>
```

3. tailwind 只能扫描 className 字符串, 如为变量则不能识别;
4. tailwind 父级 hover 时子集变字体颜色

```jsx
<div className="group peer">
  <div className="group-hover:!text-orange"></div>
</div>
<div className="peer-hover:!text-green"></div>
```

## js

1. Warning: Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop? => 先声明了 form: `const [form] = Form.useForm<当前类型>()`
   在一个暂时不存在<条件渲染>的 dom 上绑定了 form
   解决办法: 使用 forwordRef/ref 将组件拆出来,在其中绑定 form 与 父组件传入的 ref,然后继续条件渲染该组件; 当使用时,用 ref.current 取得子组件的 form, 继而进行操作

2. 同一页面 ,不可 将 model 绑定于 tab 上, 如数量不对, react 会判断为当前的 hook 存在已被卸载 / 额外新增 或 未按顺序执行, 抛出异常 => 新建个 state 去存储 当前 tab 上的的数据,保证数据源的唯一

3. 在 HTML 后缀的文件中使用 react

   1. 引入

   ```
       <script
      crossorigin
      src="https://unpkg.com/react@17/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"
    ></script>

    <script src="https://unpkg.com/babel-standalone@6.26.0/babel.js"></script>

    + 目标js文件

    <script type="text/babel" src="index.js"></script>
   ```

   2. 在 HTML 文件中设置 <div id="root"></div>

   3. 目标 js 文件的最下面绑定 root

   ```
   const domContainer = document.querySelector("#root");
   ReactDOM.render(React.createElement(组件名), domContainer);
   ```

## swr

1. swr 批量更新 某符合条件接口<比 setKey 后用 key 作为依赖来强制刷新好处: 数据无中间状态,即最大可能无感知操作>

```jsx
import { useSWRConfig } from "swr";

export function useMatchMutate() {
  const { cache, mutate } = useSWRConfig();
  return (matcher: RegExp, ...args: [any?, (boolean | undefined)?]) => {
    if (!(cache instanceof Map)) {
      throw new Error('matchMutate requires the cache provider to be a Map instance');
    }

    const keys = [];

    for (const key of cache.keys()) {
      if (matcher.test(key)) {
        keys.push(key);
      }
    }

    const mutations = keys.map((key) => {
      if (args.length) {
        return mutate(key, ...args);
      } else {
        return mutate(key);
      }
    });
    return Promise.all(mutations);
  };
}

export const getJobLogListSWRMutateKeyRegExp = memoize(function (params) { // 匹配正则
  return new RegExp(`${JSON.stringify(JOB_LOG_URL)}.*${JSON.stringify(params.robotId)}.*$`);
});

export const useRevalidateJobLogList = memoize(function (params) {
  const mutateWithRegExp = useMatchMutate();
  const jobLogListMutateRegExp = getJobLogListSWRMutateKeyRegExp(params);
  return () => mutateWithRegExp(jobLogListMutateRegExp);
});
```

## recoil

1. 使用 recoil 的 useRecoilRefresher_UNSTABLE 统一刷新时 ，如果想在纯函数中调用，不可以;如果想在事件中调用<事件中才可确定 ID>，也不可以，因为 useRecoilRefresher_UNSTABLE 为一个事件,必须在之前就绑定好一个 Refresher 事件; 故如果是一个 atomFamily/selectorFamily 时,params 不可事先绑定 => useState 存储值，后在 useLayoutEffect 中同步更新

   ```jsx
    const [targetRefreshParams, setTargetRefreshParams] = useState<TargetRefreshParams>({
        id: id!,
        type: null,
    });

    const refresher = useMemo(() => {
        return {
        workflow: workflowRefresh,
        mining: miningRefresh,
        };
    }, [miningRefresh, workflowRefresh]);

   const workflowRefresh = useRecoilRefresher_UNSTABLE(
     workflowAtoms(targetRefreshParams?.id)
   );
   const miningRefresh = useRecoilRefresher_UNSTABLE(
     miningAtoms(targetRefreshParams?.id)
   );

   // 操作时
   // 部分使用 recoil 存储的数据只能用 useRecoilRefresher_UNSTABLE 来刷新
    if (newData.itemType in refresher) {
    setTargetRefreshParams({ id: newData.itemResourceId, type: newData.itemType as TargetRefreshParams['type'] });
    }

    // 随后在 useLayoutEffect
    useLayoutEffect(() => {
        if (targetRefreshParams.type) {
            refresher?.[targetRefreshParams.type]?.();
        }
    }, [refresher, targetRefreshParams]);

   ```

## d3

1. d3 update 时渲染不对 => 在数据改变后同步刷新页面

## 其余组件库 [useSearchParams]

1. useSearchParams 使用

   ```jsx
   import { useSearchParams } from "react-router-dom";

   const [searchParams, setSearchParams] = useSearchParams();
   searchParams.get(key);
   searchParams.delete(key);
   searchParams.set(key, value);
   setSearchParams(searchParams, { state });
   ```

#### antv

```
  import { Column } from '@antv/g2plot';

  const calculatedData = {key,value}[]

  const config = useMemo(
  () => ({
    data: calculatedData ?? [],
    xField: 'key',
    yField: 'value',
    color,
    label: {
      content: (item: any) => {
        return `${item?.value}`;
      },
    },
    meta: {
      key: {
        alias: '类别',
      },
      value: {
        alias: '数量',
      },
    },
  }),
  [calculatedData, color],
  );

  useEffect(() => {
    if (barChart.current) {
      barChart.current.update(config);
    }
  }, [barChart, config]);

  useEffect(() => {
    barChart.current = new Column(chartId, config);
    barChart.current.render();

    return () => {
      if (barChart.current) {
        barChart.current.destroy();
        barChart.current = undefined;
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return  <div style={{ display: 'flex', width: '100%', height: '250px' }} id={chartId} />
```
