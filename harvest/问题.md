# todo

1. 看 测试
   1. react-data-grad
   2. antd
2. 看 ts
   1. ts-lodash
3. 前端常用工具: package 一键升级 等

# 切记

1. 考虑无网络时的操作影响
2.

## css

1. 取消双击选中文本样式

```css
-moz-user-select: none; /*火狐*/
-webkit-user-select: none; /*webkit浏览器*/
-ms-user-select: none; /*IE10*/
-khtml-user-select: none; /*早期浏览器*/
user-select: none;
```

2. 在一个 flex 布局中，如下 设置 保证内容不超出外层容器 ,如果没有设置 当内容大于剩余盒子宽度/高度时会超出父盒子。

   ```css
   flex:1;
   min-height: 0/min-width: 0;
   ```

3. width: fit-content / max-content / min-content / auto 的区别

   1. min-content:[内部最小宽度们的最大值]
      1. 均为中文时，为 1 个字的宽度
      2. 包含英文时，为最长单词的宽度
   2. max-content:[内部最大宽度们的最大值]

4. outline 的属性 [与 border 类似]
   偏移量: outline-offset:5px; => 距离 border
   outline-style / border-style:
   1. none： 默认值。定义无轮廓。
      dotted: 定义一个点状的轮廓。
      dashed: 定义一个虚线轮廓。
      solid: 定义一个实线轮廓。
      double: 定义一个双线轮廓。双线的宽度等同于 outline-width 的值。 // 内部外部均 === outline-color; 但是 中间间隔 outline-width 的距离
      groove: 定义一个 3D 凹槽轮廓。此效果取决于 outline-color 的值 // 外部 === outline-color; 内部 比 外部 深的颜色
      ridge: 定义一个 3D 凸槽轮廓。此效果取决于 outline-color 的值 // 内部 === outline-color; 外部 比 内部 深的颜色
      inset: 定义一个 3D 凹槽轮廓。此效果取决于 outline-color 的值 // 内部外部均 === outline-color;
      outset: 定义一个 3D 凸槽轮廓。此效果取决于 outline-color 的值 // 内部外部均 === 比 outline-color 深的颜色;

#### 兼容

1.  Firefox 浏览器如下设置时，高度将消失;

```css
.wrapper {
  flex: 0 1 auto;
  height: auto;
  contain: layout style paint === content;
  /*
  官方定义: contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图或它们的组合的时候，只会影响到有限的 DOM 区域，而不是整个页面。
  layout style paint === content
  layout style paint size === strict
  */

  // 设置专用 css 可解决
  @supports (-moz-appearance: none) {
    /*
    -moz-appearance: none: 判断当前为 Firefox 浏览器
    */
    flex-grow: 1;
  }
}
```

#### tailwindcss

1. tailwindcss 使用 :first-child / :last-child

```css
.variant {
  margin: 6px;
  &:first-child {
    margin-top: 0px;
  }
  &:last-child {
    margin-bottom: 0px;
  }
}
```

使用 tailwindcss:
className="my-1.5 first:mt-0 last:mb-0"

2. tailwindcss 如果想动态放置 background-image 则需写成:

```jsx
<div
  className={classnames({
    ['before:bg-[url("/images/icon1.svg")]']: 条件1,
    ['before:bg-[url("/images/icon2.svg")]']: 条件2,
    ['before:bg-[url("/images/icon3.svg")]']: 条件3,
    ['before:bg-[url("/images/icon4.svg")]']: 条件4,
  })}
></div>
```

3. tailwind 只能扫描 className 字符串, 如为变量则不能识别;
4. tailwind 父级 hover 时子集变字体颜色

```jsx
<div className="group peer">
  <div className="group-hover:!text-orange"></div>
</div>
<div className="peer-hover:!text-green"></div>
```

## js

1. Warning: Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop? => 先声明了 form: `const [form] = Form.useForm<当前类型>()`
   在一个暂时不存在<条件渲染>的 dom 上绑定了 form
   解决办法: 使用 forwordRef/ref 将组件拆出来,在其中绑定 form 与 父组件传入的 ref,然后继续条件渲染该组件; 当使用时,用 ref.current 取得子组件的 form, 继而进行操作

2. 同一页面 ,不可 将 model 绑定于 tab 上, 如数量不对, react 会判断为当前的 hook 存在已被卸载 / 额外新增 或 未按顺序执行, 抛出异常 => 新建个 state 去存储 当前 tab 上的的数据,保证数据源的唯一

3. 在 HTML 后缀的文件中使用 react

   1. 引入

   ```
       <script
      crossorigin
      src="https://unpkg.com/react@17/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"
    ></script>

    <script src="https://unpkg.com/babel-standalone@6.26.0/babel.js"></script>

    + 目标js文件

    <script type="text/babel" src="index.js"></script>
   ```

   2. 在 HTML 文件中设置 <div id="root"></div>

   3. 目标 js 文件的最下面绑定 root

   ```
   const domContainer = document.querySelector("#root");
   ReactDOM.render(React.createElement(组件名), domContainer);
   ```

4. padEnd / padStart [String]

   ```js
   /**
    str.padEnd/padStart(目标长度,?填充字符串)
   **/
   "abc".padStart(10) / "abc".padEnd(10); // "abc"
   "abc".padStart(10, "foo"); // "foofoofabc"
   "abc".padEnd(10, "foo"); // "abcfoofoof"
   "abc".padStart(1) / "abc".padEnd(1); // "abc"
   ```

5. Observer

   1. IntersectionObserver

   ```
   const options = {};
   const callback = function () {};
   const io = new IntersectionObserver(callback, option);
   // 订阅
   io.observe(document.getElementById("root"));
   // 取消订阅
   io.unobserve();
   // 关闭
   io.disconnect();

   https://mp.weixin.qq.com/s/c3sYhwrunLqCRfPI9ZCzOg
   ```

6. 通过 iframe 将 https 的页面嵌入至 http 私有化部署的网站中, iframe 下面 cookie 会丢
   原因:"SameSite=Lax"
   1. SameSite=None + Secure [需要 https] ×
      https://zhuanlan.zhihu.com/p/257860705
      https://zhuanlan.zhihu.com/p/354215929
   2. 通过 URL 将 token 取出来并登陆

## ts

1. typescript 实现一个字符串类型去左侧空格

```ts
type A = " Hello world! ";
type B = LeftTrim<A>; // 'Hello world! '
// todo typescript - lodash
```

2.  typescript 类型判定

    1.  ts 的类型为一起开发的人服务,要能做到编辑器自动推断
        eg:
        ```ts
        import { LabeledValue } from "antd/lib/select";
        const option = {
          label: `${data[label]?.name ?? label}(${number})`,
          value: label,
        } as LabeledValue;
        ```
              此时 如果 程序员未 写 value, 在 value 那行写下v, 编辑器应该给出提示

3.  转为某规则可能过于保守，并且不允许可能有效的更复杂的强制转换。如果发生这种情况，您可以使用两个断言，首先是 any（或 unknown，我们稍后会介绍），然后是所需的类型：
    const a = (expr as unknown) as T;
4.  as const
5.  类型谓词 https://www.kelen.cc/posts/612da7024971412461d8e3ad
6.  ```tsx
    1. type ToArray<Type> = Type extends any ?  Type[] : never => ToArray<string|number> = ToArray<string> | ToArray<number> = string[] | number[]
    2. type ToArray<Type> = [Type] extends [any] ?  Type[] : never =>ToArray<string|number> = (string | number)[]
    ```

7.  类型别名和接口的区别
    https://www.typescriptlang.org/docs/handbook/2/everyday-types.html 搜索标题

## swr

1. swr 批量更新 某类符合条件接口 <比 setKey 后用 key 作为依赖来强制刷新好处: 数据无中间状态,即最大可能无感知操作>

```jsx
import { useSWRConfig } from "swr";

export function useMatchMutate() {
  const { cache, mutate } = useSWRConfig();
  return (matcher: RegExp, ...args: [any?, (boolean | undefined)?]) => {
    if (!(cache instanceof Map)) {
      throw new Error('matchMutate requires the cache provider to be a Map instance');
    }

    const keys = [];

    for (const key of cache.keys()) {
      if (matcher.test(key)) {
        keys.push(key);
      }
    }

    const mutations = keys.map((key) => {
      if (args.length) {
        return mutate(key, ...args);
      } else {
        return mutate(key);
      }
    });
    return Promise.all(mutations);
  };
}

export const getListSWRMutateKeyRegExp = memoize(function (params) { // 匹配正则
  return new RegExp(`${JSON.stringify(JOB_LOG_URL)}.*${JSON.stringify(params.robotId)}.*$`);
});

export const useRevalidateJobLogList = memoize(function (params) {
  const mutateWithRegExp = useMatchMutate();
  const jobLogListMutateRegExp = getListSWRMutateKeyRegExp(params);
  return () => mutateWithRegExp(jobLogListMutateRegExp);
});
```

2. useSWRInfinite

```js
  const getKey = useCallback(
    (index: number) => {
      return [index, searchText, MINING_URL, id] as const;
    },
    [id, searchText],
  );

  const {
    data,
    isValidating,
    size,
    setSize,
  } = useSWRInfinite(
    getKey,
    (page: number, searchText) => {
      return getList(id, {
        ...params
      });
    },
    {
      revalidateFirstPage: false,
    },
  );

  // 操作
  setInterval(()=>{
    setSize( p => p + 1 )
  },300)
```

## recoil

1. 使用 recoil 的 useRecoilRefresher_UNSTABLE 统一刷新时 ，如果想在纯函数中调用，不可以;如果想在事件中调用<事件中才可确定 ID>，也不可以，因为 useRecoilRefresher_UNSTABLE 为一个事件,必须在之前就绑定好一个 Refresher 事件; 故如果是一个 atomFamily/selectorFamily 时,params 不可事先绑定 => useState 存储值，后在 useLayoutEffect 中同步更新

   ```jsx
    const [targetRefreshParams, setTargetRefreshParams] = useState<TargetRefreshParams>({
        id: id!,
        type: null,
    });

    const refresher = useMemo(() => {
        return {
        workflow: workflowRefresh,
        mining: miningRefresh,
        };
    }, [miningRefresh, workflowRefresh]);

   const workflowRefresh = useRecoilRefresher_UNSTABLE(
     workflowAtoms(targetRefreshParams?.id)
   );
   const miningRefresh = useRecoilRefresher_UNSTABLE(
     miningAtoms(targetRefreshParams?.id)
   );

   // 操作时
   // 部分使用 recoil 存储的数据只能用 useRecoilRefresher_UNSTABLE 来刷新
    if (newData.itemType in refresher) {
    setTargetRefreshParams({ id: newData.itemResourceId, type: newData.itemType as TargetRefreshParams['type'] });
    }

    // 随后在 useLayoutEffect
    useLayoutEffect(() => {
        if (targetRefreshParams.type) {
            refresher?.[targetRefreshParams.type]?.();
        }
    }, [refresher, targetRefreshParams]);

   ```

2. 假设 recoil 的 selectorFamily 中依赖了 A:类型为一个数组，还有一个 B，然后这个 A 的地址改变会判断为新的数据=>[error:把数组转为 string 传过去]，然后在一个事件里同步修改 B 和 A,会调用两次 selectorFamily 中绑定的接口

   解决办法: AB 异步改变 / 在 设置 A 时 , 在 set 事件中去 设置 B

   ```js
   export const state = selectorFamily<string[] | null, string>({
   key: 'state',
   get:
    (params) =>
    ({ get }) =>
      get(otherState(params)),
   set:
    (params) =>
    ({ set, reset }, newValue) => {
      set(otherState1(params), undefined);
      reset(otherState2(params));
      set(otherState(params), newValue);
    },
   });
   ```

3. key 值不变[JSON.stringify 后不变] 如果一个 selectorFamily:1 值 依赖着 另一个 selectorFamily:2 , 2 的 值的改变 会引起 1 重新请求接口 ; 故 将 2 的 值 去做 [数据先排序，再序列化为`字符串`，使其做为请求依赖可以有效利用已有缓存 :JSON.parse(JSON.stringify(value))]

## d3

1. d3 update 时渲染不对 => 在数据改变后同步刷新页面

## 其余组件库 [useSearchParams]

1. useSearchParams 使用

   ```jsx
   import { useSearchParams } from "react-router-dom";

   const [searchParams, setSearchParams] = useSearchParams();
   searchParams.get(key);
   searchParams.delete(key);
   searchParams.set(key, value);
   setSearchParams(searchParams, { state });
   ```

#### antv

```
  import { Column } from '@antv/g2plot';

  const calculatedData = {key,value}[]

  const config = useMemo(
  () => ({
    data: calculatedData ?? [],
    xField: 'key',
    yField: 'value',
    color,
    label: {
      content: (item: any) => {
        return `${item?.value}`;
      },
    },
    meta: {
      key: {
        alias: '类别',
      },
      value: {
        alias: '数量',
      },
    },
  }),
  [calculatedData, color],
  );

  useEffect(() => {
    if (barChart.current) {
      barChart.current.update(config);
    }
  }, [barChart, config]);

  useEffect(() => {
    barChart.current = new Column(chartId, config);
    barChart.current.render();

    return () => {
      if (barChart.current) {
        barChart.current.destroy();
        barChart.current = undefined;
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return  <div style={{ display: 'flex', width: '100%', height: '250px' }} id={chartId} />
```

### typescript-lodash

1. extends infer

#### common

1. IsEqual

#### string

1. LastIndexOf
2. PadStart & PadEnd
3. Uppercase & Lowercase 是 ts 自带的吗
4. SubStr
