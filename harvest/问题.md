1. d3 update 时渲染不对 => 在数据改变后同步刷新页面
2. 使用 recoil 的 useRecoilRefresher_UNSTABLE 统一刷新时 ，如果想在纯函数中调用，不可以;如果想在事件中调用<事件中才可确定 ID>，也不可以，因为 useRecoilRefresher_UNSTABLE 为一个事件,必须在之前就绑定好一个 Refresher 事件; 故如果是一个 atomFamily/selectorFamily 时,params 不可事先绑定 => useState 存储值，后在 useLayoutEffect 中同步更新

   ```jsx
    const [targetRefreshParams, setTargetRefreshParams] = useState<TargetRefreshParams>({
        id: id!,
        type: null,
    });

    const refresher = useMemo(() => {
        return {
        workflow: workflowRefresh,
        mining: miningRefresh,
        };
    }, [miningRefresh, workflowRefresh]);

   const workflowRefresh = useRecoilRefresher_UNSTABLE(
     workflowAtoms(targetRefreshParams?.id)
   );
   const miningRefresh = useRecoilRefresher_UNSTABLE(
     miningAtoms(targetRefreshParams?.id)
   );

   // 操作时
   // 部分使用 recoil 存储的数据只能用 useRecoilRefresher_UNSTABLE 来刷新
    if (newData.itemType in refresher) {
    setTargetRefreshParams({ id: newData.itemResourceId, type: newData.itemType as TargetRefreshParams['type'] });
    }

    // 随后在 useLayoutEffect
    useLayoutEffect(() => {
        if (targetRefreshParams.type) {
            refresher?.[targetRefreshParams.type]?.();
        }
    }, [refresher, targetRefreshParams]);

   ```

3. useSearchParams 使用

   ```jsx
   const [searchParams, setSearchParams] = useSearchParams();
   searchParams.get(key);
   searchParams.delete(key);
   searchParams.set(key, value);
   setSearchParams(searchParams, { state });
   ```

4. swr 批量更新 某符合条件接口<比 setKey 后用 key 作为依赖来强制刷新好处: 数据无中间状态,即最大可能无感知操作>

```jsx
import { useSWRConfig } from "swr";

export function useMatchMutate() {
  const { cache, mutate } = useSWRConfig();
  return (matcher: RegExp, ...args: [any?, (boolean | undefined)?]) => {
    if (!(cache instanceof Map)) {
      throw new Error('matchMutate requires the cache provider to be a Map instance');
    }

    const keys = [];

    for (const key of cache.keys()) {
      if (matcher.test(key)) {
        keys.push(key);
      }
    }

    const mutations = keys.map((key) => {
      if (args.length) {
        return mutate(key, ...args);
      } else {
        return mutate(key);
      }
    });
    return Promise.all(mutations);
  };
}

export const getJobLogListSWRMutateKeyRegExp = memoize(function (params) { // 匹配正则
  return new RegExp(`${JSON.stringify(JOB_LOG_URL)}.*${JSON.stringify(params.robotId)}.*$`);
});

export const useRevalidateJobLogList = memoize(function (params) {
  const mutateWithRegExp = useMatchMutate();
  const jobLogListMutateRegExp = getJobLogListSWRMutateKeyRegExp(params);
  return () => mutateWithRegExp(jobLogListMutateRegExp);
});
```

5. 取消双击选中文本样式

```css
-moz-user-select: none; /*火狐*/
-webkit-user-select: none; /*webkit浏览器*/
-ms-user-select: none; /*IE10*/
-khtml-user-select: none; /*早期浏览器*/
user-select: none;
```

6. tailwindcss 使用 :first-child / :last-child

```css
.variant {
  margin: 6px;
  &:first-child {
    margin-top: 0px;
  }
  &:last-child {
    margin-bottom: 0px;
  }
}
```

使用 tailwindcss:
className="my-1.5 first:mt-0 last:mb-0"

7. Warning: Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop? => 先声明了 form: `const [form] = Form.useForm<当前类型>()`
   在一个暂时不存在<条件渲染>的 dom 上绑定了 form
   解决办法: 使用 forwordRef/ref 将组件拆出来,在其中绑定 form 与 父组件传入的 ref,然后继续条件渲染该组件; 当使用时,用 ref.current 取得子组件的 form, 继而进行操作

8. tailwind 只能扫描 className 字符串, 如为变量则不能识别;
