# todo

1. 看 测试
   1. react-data-grad
   2. antd
2. 看 ts
   1. ts-lodash
3. 前端常用工具: package 一键升级 等

## 切记

1. 考虑无网络时操作的影响
2. 考虑不同 显示屏下 的影响[兼容可视化]
3. 如果 某页面 的某部分 UI 的 UI 布局类似，但是 显示内容 及 内在逻辑 及 内在逻辑的类型 不同，则要拆出公共的显示组件，逻辑请在不同的组件中处理

   1. ts 类型定义复杂
   2. 逻辑混杂糅合,不直观

   ```tsx
   interface BaseOverviewInfo {
     title: string;
     unit?: string;
   }
   type GetDistributionDetail = (model?: OverviewModel) => string | undefined;
   type GetDurationDetail = (detail: OverviewModel["duration"]) => string;
   type GetStepDetail = (detail: OverviewModel["step"]) => string;
   type GetRecallDetail = (model?: OverviewModel) => string | undefined;
   interface DistributionOverviewInfo extends BaseOverviewInfo {
     key: "distribution";
     footer: GetDistributionDetail;
     getNumberKey?: GetDistributionDetail;
   }
   interface DurationOverviewInfo extends BaseOverviewInfo {
     key: "duration";
     footer: GetDurationDetail;
     getNumberKey?: GetDurationDetail;
   }
   interface StepOverviewInfo extends BaseOverviewInfo {
     key: "step";
     footer: GetStepDetail;
     getNumberKey?: GetStepDetail;
   }
   interface RecallOverviewInfo extends BaseOverviewInfo {
     key: "recall";
     footer: GetRecallDetail;
     getNumberKey?: GetRecallDetail;
   }
   type OverviewsInfo =
     | DistributionOverviewInfo
     | DurationOverviewInfo
     | StepOverviewInfo
     | RecallOverviewInfo;

   const overviewsInfo: OverviewsInfo[] = [
     {
       title: "案例数量",
       key: "distribution",
       footer: (model?: OverviewModel) =>
         model?.totalCases
           ? `${toDateTimeFormat(model?.distribution?.startTime) ?? ""} - ${
               toDateTimeFormat(model?.distribution?.endTime) ?? ""
             }`
           : undefined,
     },
     {
       title: "平均耗时",
       key: "duration",
       footer: (detail?: OverviewModel["duration"]) =>
         detail?.max ? `最长耗时 ${formatSeconds(detail?.max) ?? ""}` : "",
       getNumberKey: (detail: OverviewModel["duration"]) =>
         `${formatSeconds(detail.average)}`,
     },
     {
       title: "平均步骤",
       key: "step",
       footer: (detail: OverviewModel["step"]) => `最长 ${detail.max ?? ""} 步`,
       getNumberKey: (detail: OverviewModel["step"]) =>
         `${detail.average?.toFixed(2) ?? ""}`,
       unit: "步",
     },
     {
       title: "返工率",
       key: "recall",
       footer: (model?: OverviewModel) =>
         `最多返工 ${model?.recall?.max ?? ""} 次`,
       getNumberKey: (model?: OverviewModel) =>
         model?.totalCases
           ? `${((1 - model?.recall?.rate) * 100)?.toFixed(3) ?? ""}`
           : undefined,
       unit: "%",
     },
   ];

   const getDataDetail = useCallback(
     (item: OverviewsInfo, model?: OverviewModel) => {
       if (model) {
         let number, footerRender;
         switch (item.key) {
           case "distribution":
             number = item.getNumberKey
               ? item.getNumberKey(model)
               : model?.totalCases;
             footerRender = item.footer?.(model) ?? "";
             break;
           case "duration":
             number = item.getNumberKey
               ? item.getNumberKey(model.duration)
               : model?.totalCases;
             footerRender = item.footer?.(model.duration) ?? "";
             break;
           case "step":
             number = item.getNumberKey
               ? item.getNumberKey(model.step)
               : model?.totalCases;
             footerRender = item.footer?.(model.step) ?? "";
             break;
           case "recall":
             number = item.getNumberKey
               ? item.getNumberKey(model)
               : model?.totalCases;
             footerRender = item.footer?.(model) ?? "";
             break;
         }
         return (
           <div className="flex-1">
             <span className="text-sm text-[#515a6b]">
               {item.title.replace("案例", processName)}
             </span>
             <div className="text-xl font-bold text-[#162339]">
               {number !== undefined ? `${number} ${item.unit ?? ""}` : "无"}
             </div>
             <span className="text-xs text-[#7f8692] block">
               {footerRender}
             </span>
           </div>
         );
       }

       return;
     },
     [processName]
   );

   return (
     <div className="flex bg-white py-3 h-[90px]">
       {overviewsInfo.map((item) => (
         <div
           key={item.title}
           className={clx(
             "flex flex-1 pl-6 before:w-[42px] before:h-[42px] before:mr-4 before:mt-1  before:bg-no-repeat",
             {
               ['before:bg-[url("/images/mining/overview/count.svg")]']:
                 item.title === "案例数量",
               ['before:bg-[url("/images/mining/overview/duration.svg")]']:
                 item.title === "平均耗时",
               ['before:bg-[url("/images/mining/overview/variant.svg")]']:
                 item.title === "平均步骤",
               ['before:bg-[url("/images/mining/overview/rework.svg")]']:
                 item.title === "返工率",
             }
           )}
         >
           {getDataDetail(item, model)}
         </div>
       ))}
     </div>
   );
   ```

   改为

   ```tsx
   <div className="flex bg-white py-3 h-[90px]">
     <OverviewCaseCountCard />
     <OverviewDurationCard />
     <OverviewStepCard />
     <OverviewRecallCard />
   </div>;
   // 其中 上述4个组件 为逻辑处理专用组件:
   // OverviewCaseCountCard
   const { model, loading } = useOverviewsModel(id);
   const desc = useMemo(() => {
     return model?.totalCases
       ? `${toDateTimeFormat(model?.distribution?.startTime) ?? ""} - ${
           toDateTimeFormat(model?.distribution?.endTime) ?? ""
         }`
       : "";
   }, [
     model?.distribution?.endTime,
     model?.distribution?.startTime,
     model?.totalCases,
   ]);
   const processName = useProcessName();
   const title = useMemo(() => {
     return (processName ?? "案例") + "数量";
   }, [processName]);
   return (
     <OverviewCard
       title={title}
       count={loading ? "" : model?.totalCases}
       desc={desc}
       className="before:bg-[url('/images/mining/overview/count.svg')]"
     />
   );

   // OverviewCard:
   const OverviewCard = React.memo<{
     title?: string;
     count?: string | number;
     desc?: ReactNode;
     className?: string;
   }>(function OverviewCard({ title, count, desc, className }) {
     return (
       <div
         className={clx(
           "flex flex-1 pl-6 before:w-[42px] before:h-[42px] before:mr-4 before:mt-1  before:bg-no-repeat",
           className
         )}
       >
         <div className="flex-1">
           <span className="text-sm text-[#515a6b]">{title}</span>
           <div className="text-xl font-bold text-[#162339]">
             {count ?? "无"}
           </div>
           <div className="text-xs text-[#7f8692] block">{desc}</div>
         </div>
       </div>
     );
   });
   ```

4. 尽量做单页应用[不要因为某功能而跳转到新的 tab,尽量将当前 tab 直接跳转过去]
   因为可能会有用户在新 tab 操作后，直接切回旧 tab，然后就想用 新 tab 的功能！
5. 关注 组件库[如 tailwindcss 等]的新版本，及了解并使用新功能
6. [约定式提交规范](https://www.conventionalcommits.org/zh-hans/v1.0.0/)
7. Edge 扩展程序 在 C:\Users\用户名\AppData\Local\Microsoft\Edge\User Data\Default\Extensions 中
8. 引用错误: ctrl + g 清空后输入>reload 重新装载
9. [查看兼容性](https://caniuse.com/)
10. 增加条理性

## html

1. 查看当前 html: $0
2. [img 新属性](https://juejin.cn/post/6844903922109267976)
   1. srcset
   2. sizes

## dom

1. event.stopPropagation 与 event.stopImmediatePropagation 的区别
   ```
   stopPropagation 阻止捕获和冒泡阶段中当前事件的进一步传播。
   stopImmediatePropagation 阻止事件冒泡并且阻止相同事件的其他侦听器被调用。
   ```
2. isTrusted:
   公用 event 的属性
   返回一个 boolean,为 true 表明当前事件是由用户行为触发(比如说真实的鼠标点击触发一个 click 事件), 为 false 表明事件由一个脚本生成的(使用事件构造方法,比如 event.initEvent)

   ```tsx
   /*
     问题: 在页面中有 一个带pop的按钮和流程图,按钮 监听了 mousedown 事件,页面其他地方触发时候会调用 setVisible(false) 来取消按钮的pop显示;
     流程图 需要调接口 ,然后自动去 fitView ,fitView 的时候会自动调用 mousedown 事件
     解决办法: setVisible 之前判断一下
     */

   useLayoutEffect(() => {
     const fn = (e: MouseEvent) => {
       if (!e.isTrusted) return;
       setVisible(false);
     };
     // addEventListener 第三个参数 为options:{once:boolean;capture:boolean;passive:boolean} / useCapture:boolean = false
     document.addEventListener("mousedown", fn, false);
     return () => {
       document.removeEventListener("mousedown", fn, false);
     };
   }, []);
   ```

3. Observer

   1. IntersectionObserver

      ```
      const options = {};
      const callback = function () {};
      const io = new IntersectionObserver(callback, option);
      // 订阅
      io.observe(document.getElementById("root"));
      // 取消订阅
      io.unobserve();
      // 关闭
      io.disconnect();

      https://mp.weixin.qq.com/s/c3sYhwrunLqCRfPI9ZCzOg
      ```

   2. ResizeObserver
      eg: 获取页面当前高度

      ```tsx
      const rootRef = useRef<HTMLDivElement>(null)
      const [height, setHeight] = useState(defaultHeight);
      useEffect(()=>{
          const ob = new ResizeObserver(
        throttle(
          (entries) => {
            for (const item of entries) {
              setHeight(item.contentRect.height);
            }
          },
          70,
          { trailing: true },
        ),
      );
      ob.observe(rootRef.current!);
      return () => ob.disconnect();
      },[])
      return <div ref={rootRef}>
        {此时 height 为 动态值 }
      </div>

      ```

4. event.target 与 event.currentTarget 的区别:
   1. event.target 当前点击的元素
   2. event.currentTarget 触发的元素 例如 onClick 绑定的元素
5. API[https://developer.mozilla.org/zh-CN/docs/Web/API/Element]

   ```tsx
   document.createElement();
   document.addEventListener();
   document.removeEventListener();
   document.contains();
   document.getSelection();
   document.elementsFromPoint();
   /*
   document.createEvent();
   document.initEvent();
   */
   document.dispatchEvent();
   ```

6. dispatchEvent(new Event()) 与 dispatchEvent(new CustomEvent()) 的区别?
   1. 参数
   ```tsx
   dispatchEvent(new Event("resize"));
   dispatchEvent(
     new CustomEvent("mousedown", { bubbles: true, cancelable: true })
   );
   ```

```tsx
getAttribute;
closest;
toggle;
dataset;
matches;
contains;
```

## css

1. 取消双击选中文本样式

```css
-moz-user-select: none; /*火狐*/
-webkit-user-select: none; /*webkit浏览器*/
-ms-user-select: none; /*IE10*/
-khtml-user-select: none; /*早期浏览器*/
user-select: none;
```

2. 在一个 flex 布局中，如下 设置 保证内容不超出外层容器 ,如果没有设置 当内容大于剩余盒子宽度/高度时会超出父盒子。

```css
flex: 1;
min-height: 0;
min-width: 0;
```

3.  width: fit-content / max-content / min-content / auto 的区别

    1. min-content:[内部最小宽度们的最大值]
       1. 均为中文时，为 1 个字的宽度
       2. 包含英文时，为最长单词的宽度
    2. max-content:[内部最大宽度们的最大值]

4.  outline 的属性 [与 border 类似]
    偏移量: outline-offset:5px; => 距离 border
    outline-style / border-style:

    1. none： 默认值。定义无轮廓。
       dotted: 定义一个点状的轮廓。
       dashed: 定义一个虚线轮廓。
       solid: 定义一个实线轮廓。
       double: 定义一个双线轮廓。双线的宽度等同于 outline-width 的值。 // 内部外部均 === outline-color; 但是 中间间隔 outline-width 的距离
       groove: 定义一个 3D 凹槽轮廓。此效果取决于 outline-color 的值 // 外部 === outline-color; 内部 比 外部 深的颜色
       ridge: 定义一个 3D 凸槽轮廓。此效果取决于 outline-color 的值 // 内部 === outline-color; 外部 比 内部 深的颜色
       inset: 定义一个 3D 凹槽轮廓。此效果取决于 outline-color 的值 // 内部外部均 === outline-color;
       outset: 定义一个 3D 凸槽轮廓。此效果取决于 outline-color 的值 // 内部外部均 === 比 outline-color 深的颜色;

5.  gap

    column-gap / row-gap

6.  display: flex 与 display:-webkit-box 的区别

    超出一行显示省略号的 css 中, 后三者配套使用

    ```
      overflow: hidden;
      text-overflow: ellipsis;
      word-wrap: break-word;
      word-break: break-all;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: n;
      display: -webkit-box; / display: -webkit-inline-box;
    ```

7.  overflow:hidden 不可限制 box-sizing: border-box 时候的 边框超出情况

    ```html
    <div style="width: 100%; height: 200px; background-color: yellow">
      <div
        style="
           width: 100%;
           height: 50px;
           max-height: 50px;
           border: 40px dashed burlywood;
           background-color: yellowgreen;
           display: flex;
           box-sizing: border-box;
           overflow: hidden; 
         "
      >
        <div
          style="
             min-height: 0;
             min-width: 0;
             align-items: center;
             background-color: pink;
           "
        >
          111
        </div>
      </div>
    </div>
    ```

8.  如何 让 子级 继承 父级的 css

    把子级 的 css 设为 inherit

9.  不使用!important 的方式去增加样式: .class.class.class
10. pointer-events
11. :has, :is, :where 区别

    1. :is

       ```css
       /* 设置 header, main, footer 里的任意一个 p 标签的 hover 状态 */
       header p:hover,
       main p:hover,
       footer p:hover {
         /* … */
       }

       /* 可以使用 :is() 简写为以下 */
       :is(header, main, footer) p:hover {
         /* … */
       }

       some-element::before,
       some-element::after {
         /* … */
       }

       /* 不能选择伪元素 */
       some-element:is(::before, ::after) {
         /* … */
       }

       /*当前部分支持的selector 会生效*/
       :is(:valid, :unsupported) {
         /* … */
       }
       ```

    2. :has

       1. :is :where 区别 :
          :is 优先级为 它的选择器列表中优先级最高的选择器决定的。 ，:where 优先级为 0

    3. :has

    ```css

      /* 只要 <a> 元素里面有 <img> 元素，这个 <a> 元素就会匹配：*/
      a:has(img) { /_ … _/ }
      /* 匹配直接包含 <img> 子元素的 <a> 元素 */
      a:has(> img) { /_ … _/ }
      /* 匹配其后紧跟着 <p> 元素的 <h1> 元素 */
      h1:has(+ p) { /_ … _/ }
      /*只要 <article> 元素内有 <h5> 元素或者有 <p> 元素就会匹配*/
      article:has(h5, p) { /_ … _/ }
      /* <article> 元素内同时有 <h5> 元素和 <p> 元素才匹配 */
      article:has(h5):has(p) { /_ … _/ }

    ```

12. opacity 会遗传给子元素 即:子元素实际 opacity = 父元素 opacity \* 子元素设置的 opacity
13. [clip-path](http://tools.jb51.net/code/css3path)

#### 兼容

1.  Firefox 浏览器如下设置时，高度将消失;

```css
.wrapper {
  flex: 0 1 auto;
  height: auto;
  contain: layout style paint === content;
  /*
官方定义: contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图或它们的组合的时候，只会影响到有限的 DOM 区域，而不是整个页面。
layout style paint === content
layout style paint size === strict
*/

  // 设置专用 css 可解决
  @supports (-moz-appearance: none) {
    /*
 -moz-appearance: none: 判断当前为 Firefox 浏览器
 */
    flex-grow: 1;
  }
}
```

## tailwindcss

1. tailwindcss 使用 :first-child / :last-child

```css
.variant {
  margin: 6px;
  &:first-child {
    margin-top: 0px;
  }
  &:last-child {
    margin-bottom: 0px;
  }
}
```

使用 tailwindcss:
className="my-1.5 first:mt-0 last:mb-0"

2. tailwindcss 如果想动态放置 background-image 则需写成:

```jsx
<div
  className={classnames({
    ['before:bg-[url("/images/icon1.svg")]']: 条件1,
    ['before:bg-[url("/images/icon2.svg")]']: 条件2,
    ['before:bg-[url("/images/icon3.svg")]']: 条件3,
    ['before:bg-[url("/images/icon4.svg")]']: 条件4,
  })}
></div>
```

3. tailwind 只能扫描 className 字符串, 如为变量则不能识别;
4. tailwind 父级 hover 时子集变字体颜色

```jsx
<div className="group peer">
<div className="group-hover:!text-orange"></div>
</div>
<div className="peer-hover:!text-green"></div>
```

5. 改变当前元素的子元素的 css
   注意: 当前版本(3.1.4) 不可跳级选择

```jsx
<div className="[&>.ant-select-selector]:min-w-0 [&>.ant-select-selector>div>.ant-select-selection-overflow-item]:bg-[yellow]"></div>
```

6. 如 想改变当前元素的子元素的 hover 等状态

```jsx
<div className="[&_.ant-steps-item-tail]:after:!bg-[#d0d3d7]"></div>
```

7. 使用 rgba 时其中不可有空格

```jsx
<div className="bg-[rgba(0,0,0,0.4)]"></div>
```

## js

1. Warning: Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop? => 先声明了 form: `const [form] = Form.useForm<当前类型>()`
   在一个暂时不存在<条件渲染>的 dom 上绑定了 form
   解决办法: 使用 forwordRef/ref 将组件拆出来,在其中绑定 form 与 父组件传入的 ref,然后继续条件渲染该组件; 当使用时,用 ref.current 取得子组件的 form, 继而进行操作

2. 同一页面 ,不可 将 model 绑定于 tab 上, 如数量不对, react 会判断为当前的 hook 存在已被卸载 / 额外新增 或 未按顺序执行, 抛出异常 => 新建个 state 去存储 当前 tab 上的的数据,保证数据源的唯一

3. 在 HTML 后缀的文件中使用 react

   1. 引入

```jsx

  <script
     crossorigin
     src="https://unpkg.com/react@17/umd/react.development.js">
  </script>

  <script
    crossorigin
    src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"
  ></script>

   <script src="https://unpkg.com/babel-standalone@6.26.0/babel.js"></script>

// 目标 js 文件

   <script type="text/babel" src="index.js"></script>

```

2. 在 HTML 文件中设置 <div id="root"></div>

3. 目标 js 文件的最下面绑定 root

```jsx
const domContainer = document.querySelector("#root");
ReactDOM.render(React.createElement(组件名), domContainer);
```

4. padEnd / padStart [String]

```js
/**
 str.padEnd/padStart(目标长度,?填充字符串)
**/
"abc".padStart(10) / "abc".padEnd(10); // "abc"
"abc".padStart(10, "foo"); // "foofoofabc"
"abc".padEnd(10, "foo"); // "abcfoofoof"
"abc".padStart(1) / "abc".padEnd(1); // "abc"
```

5. 通过 iframe 将 https 的页面嵌入至 http 私有化部署的网站中, iframe 下面 cookie 会丢
   原因:"SameSite=Lax"

   1. SameSite=None + Secure [需要 https] ×
      https://zhuanlan.zhihu.com/p/257860705
      https://zhuanlan.zhihu.com/p/354215929
   2. 通过 URL 将 token 取出来并登陆

6. 页面缩放判断

   1. https://www.zhangxinxu.com/wordpress/2021/02/js-if-page-zoom/

7. scrollIntoView 滚动父元素至当前元素可见
   1. https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView

## react

1. 新 API
   startTransition / useTransition / useDeferredValue
2. useState 参数如为 函数,函数不可返回 Promise
   ```jsx
   const [state, setState] = useState(() => {
     // 不可使用 async , 不会等运行完的
     const initialState = someExpensiveComputation(props);
     return initialState;
   });
   ```

## ts

1.  typescript 类型判定

    1.  ts 的类型为一起开发的人服务,要能做到编辑器自动推断
        eg:

        ```tsx
        import { LabeledValue } from "antd/lib/select";
        const option = {
          label: `${data[label]?.name ?? label}(${number})`,
          value: label,
        } as LabeledValue;
        ```

        此时 如果 程序员未 写 value, 在 value 那行写下 v, 编辑器应该给出提示

    2.  转为某规则可能过于保守，并且不允许可能有效的更复杂的强制转换。如果发生这种情况，您可以使用两个断言，首先是 any（或 unknown），然后是所需的类型：

        ```tsx
        const a = expr as unknown as T;
        ```

    3.  类型谓词 https://www.kelen.cc/posts/612da7024971412461d8e3ad

    4.  https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types

        ```jsx
        1.  type ToArray<Type> = Type extends any ? Type[] : never
            ToArray<string|number> = ToArray<string> | ToArray<number> = string[] | number[]

        2.  type ToArray<Type> = [Type] extends [any] ? Type[] : never
            ToArray<string|number> = (string | number)[]
        ```

    5.  https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as

2.  类型别名和接口的区别
    https://www.typescriptlang.org/docs/handbook/2/everyday-types.html 搜索标题

## swr

1. swr 批量更新 某类符合条件接口 <比 setKey 后用 key 作为依赖来强制刷新好处: 数据无中间状态,即最大可能无感知操作>

```jsx
import { useSWRConfig } from "swr";

export function useMatchMutate() {
const { cache, mutate } = useSWRConfig();
return (matcher: RegExp, ...args: [any?, (boolean | undefined)?]) => {
if (!(cache instanceof Map)) {
  throw new Error('matchMutate requires the cache provider to be a Map instance');
}

const keys = [];

for (const key of cache.keys()) {
  if (matcher.test(key)) {
    keys.push(key);
  }
}

const mutations = keys.map((key) => {
  if (args.length) {
    return mutate(key, ...args);
  } else {
    return mutate(key);
  }
});
return Promise.all(mutations);
};
}

export const getListSWRMutateKeyRegExp = memoize(function (params) { // 匹配正则
return new RegExp(`${JSON.stringify(JOB_LOG_URL)}.*${JSON.stringify(params.robotId)}.*$`);
});

export const useRevalidateJobLogList = memoize(function (params) {
const mutateWithRegExp = useMatchMutate();
const jobLogListMutateRegExp = getListSWRMutateKeyRegExp(params);
return () => mutateWithRegExp(jobLogListMutateRegExp);
});
```

2. useSWRInfinite

   ```tsx
   const getKey = useCallback(
     (index: number) => {
       return [index, searchText, MINING_URL, id] as const;
     },
     [id, searchText]
   );

   const { data, isValidating, size, setSize } = useSWRInfinite(
     getKey,
     (page: number, searchText) => {
       return getList(id, {
         ...params,
       });
     },
     {
       revalidateFirstPage: false,
     }
   );

   // 操作
   setInterval(() => {
     setSize((p) => p + 1);
   }, 300);
   ```

## recoil

1. 使用 recoil 的 useRecoilRefresher_UNSTABLE 统一刷新时 ，如果想在纯函数中调用，不可以;如果想在事件中调用<事件中才可确定 ID>，也不可以，因为 useRecoilRefresher_UNSTABLE 为一个事件,必须在之前就绑定好一个 Refresher 事件; 故如果是一个 atomFamily/selectorFamily 时,params 不可事先绑定 => useState 存储值，后在 useLayoutEffect 中同步更新

```tsx
const [targetRefreshParams, setTargetRefreshParams] =
  useState<TargetRefreshParams>({
    id: id!,
    type: null,
  });

const refresher = useMemo(() => {
  return {
    workflow: workflowRefresh,
    mining: miningRefresh,
  };
}, [miningRefresh, workflowRefresh]);

const workflowRefresh = useRecoilRefresher_UNSTABLE(
  workflowAtoms(targetRefreshParams?.id)
);
const miningRefresh = useRecoilRefresher_UNSTABLE(
  miningAtoms(targetRefreshParams?.id)
);

// 操作时 部分使用 recoil 存储的数据只能用 useRecoilRefresher_UNSTABLE 来刷新
if (newData.itemType in refresher) {
  setTargetRefreshParams({
    id: newData.itemResourceId,
    type: newData.itemType as TargetRefreshParams["type"],
  });
}

// 随后在 useLayoutEffect
useLayoutEffect(() => {
  if (targetRefreshParams.type) {
    refresher?.[targetRefreshParams.type]?.();
  }
}, [refresher, targetRefreshParams]);
```

2. 假设 recoil 的 selectorFamily 中依赖了 A:类型为一个数组，还有一个 B，然后这个 A 的地址改变会判断为新的数据=>[解决方式:把数组转为 string 传过去]，然后在一个事件里同步修改 B 和 A,会调用两次 selectorFamily 中绑定的接口

解决办法: AB 异步改变 / 在 设置 A 时 , 在 set 事件中去 设置 B

```tsx
export const state = selectorFamily<string[] | null, string>({
  key: "state",
  get:
    (params) =>
    ({ get }) =>
      get(otherState(params)),
  set:
    (params) =>
    ({ set, reset }, newValue) => {
      set(otherState1(params), undefined);
      reset(otherState2(params));
      set(otherState(params), newValue);
    },
});
```

3. key 值不变[JSON.stringify 后不变] 如果一个 selectorFamily:1 值 依赖着 另一个 selectorFamily:2 , 2 的 值的改变 会引起 1 重新请求接口 ; 故 将 2 的 值 去做 [数据先排序，再序列化为`字符串`，使其做为请求依赖可以有效利用已有缓存 :JSON.parse(JSON.stringify(value))]
4. useRecoilCallback
   1. 如果 不使用 useRecoilCallback 提供的 reset/get/set 方法，则 建议用 react 的 useCallback 方法
   2. 使用 useRecoilCallback 的 set 方法会减少页面重新渲染次数
5. reset 一个 selector 时, 会触发其 set 方法
6. recoil 的缺点
   画图像的时候，要在一个事件中动态的添加节点，添加边，均要根据算法动态计算
   recoil 无法在同一个 useRecoilCallback 中去获取每次更新后的新的 snapshot，而 jotai 能做到

## d3

1. d3 update 时渲染不对 => 在数据改变后同步刷新页面

## 其余组件库

### react-router-dom

1. useSearchParams 使用

```jsx
import { useSearchParams } from "react-router-dom";

const [searchParams, setSearchParams] = useSearchParams();
searchParams.get(key);
searchParams.delete(key);
searchParams.set(key, value);
setSearchParams(searchParams, { state });
```

2. Outlet 占位符
3. 如果想 路由 a 和 路由 b 同时显示同一个侧边菜单栏[状态相同] 且 不影响原有路由使用

   ```ts
   // routes.ts
   {
     path: 'apps/:appId',
     component: lazy(() => import('../layout/AppLayout/AppLayoutContent')),
     routes: [
              {
                path: '',
                component: lazy(() => import('../pages/apps/DataSetting')),
                routes: [
                  {
                    path: 'a',
                    component: lazy(() => import('../pages/apps/DataSetting/A/empty')),
                  },
                  {
                    path: 'a/:id',
                    component: lazy(() => import('../pages/apps/DataSetting/A')),
                  },
                  {
                    path: 'b/:id',
                    component: lazy(() => import('../pages/apps/DataSetting/B')),
                  },
                ],
              },
            ],
   },
   ```

   ```tsx
   // 因为 path: '' 是会默认进入的，所以 DataSetting 中要注意做路由拦截显示
   const { pathname } = useLocation();
   const { appId } = useParams() as { appId: string };
   const aUrl = `/apps/${appId}/a`;
   const bUrl = `/apps/${appId}/b`;
   if (!(pathname.startsWith(aUrl) || pathname.startsWith(bUrl))) {
     // 显示 Loading效果
     return (
       <div className="w-full h-24 flex-center">
         <Loading />
       </div>
     );
   }
   ```

### antv

1. 基本使用

```tsx

import { Column } from '@antv/g2plot';

const calculatedData = {key,value}[]

const config = useMemo(
() => ({
 data: calculatedData ?? [],
 xField: 'key',
 yField: 'value',
 color,
 label: {
   content: (item: any) => {
     return `${item?.value}`;
   },
 },
 meta: {
   key: {
     alias: '类别',
   },
   value: {
     alias: '数量',
   },
 },
}),
[calculatedData, color],
);

useEffect(() => {
 if (barChart.current) {
   barChart.current.update(config);
 }
}, [barChart, config]);

useEffect(() => {
 barChart.current = new Column(chartId, config);
 barChart.current.render();

 return () => {
   if (barChart.current) {
     barChart.current.destroy();
     barChart.current = undefined;
   }
 };
 // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);

return  <div style={{ display: 'flex', width: '100%', height: '250px' }} id={chartId} />
```

2. 点击按钮时， 获取 Column 的 slider 的 当前值
   1. 方法一: 事件监听 on("slider:onmouseup") => 文档上没写，不建议使用 && 触发有些问题
   2. 用 useImperativeHandle + ref 绑定 Column 实例，点击的时候获取 (Column.chart as any).filteredData => Column.chart.filteredData 为 protected 类型

### typescript-lodash

1. extends infer

#### common

1. IsEqual

#### string

1. LastIndexOf
2. PadStart & PadEnd
3. Uppercase & Lowercase 是 ts 自带的吗
4. SubStr

### [github 文档](https://docs.github.com/cn)

### [turfjs](https://turfjs.fenxianglu.cn/category/)

### [前端工程化](https://mp.weixin.qq.com/s/pVI1pmZdNIRWguoV5HKAeg)

### 生产环境

1. 本地 message 正常, 线上 message 不弹出

```tsx
// 本地自动导入:
import message from "antd/lib/message";
// 改为
import { message } from "antd";
// 即可解决
// antd/lib/* 来导入类型是不影响的
```

### svg

1. g
2. defs
3. marker
4. use

### 其他

1. 将修改过的 csv 文档 重置回 csv 文档
   1. 下载 notepad ++
   2. 选择文件并将文件转为 utf-8 格式
   3. 重新保存设置
2. todo 组件滚动到可视区懒加载
