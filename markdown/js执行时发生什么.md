1. 语法分析
   1. 如有问题则调至下一个script并报语法错误
2. 预编译
   1. 创建执行上下文 **执行环境**，同时:
      1. 创建变量对象
         1. 创建arguments对象
         2. 函数声明提升 => 指向内存地址的指针
         3. 变量声明提升 => undefined
      2. 创建作用域链 => 当前执行环境的变量对象与上层环境的活动对象组成，保证有序访问[从左至右查找，找到则停止，找不到则一直查找到全局作用域，再找不到抛出引用错误]
      3. 确定this指向
3. 执行 变量对象=>活动对象

JS运行环境: 
    1. 全局环境
    2. 函数环境
    3. eval
每次进入一个运行环境均会生成一个新的**执行上下文**,进而积累为**函数调用栈**:
    1. 特点: 先进后出，后进先出
    2. 顺序:
       1. 栈底: 全局执行上下文
       2. 栈顶: 当前执行上下文
   
*在全局环境中，window对象就是全局执行上下文的变量对象，所有的变量和函数都是window对象的属性方法。*

![作用域](https://camo.githubusercontent.com/681a962dac2e1b1148b6fb97b0ebe3265dc7a3f0f2a5cb0e1b88259e0c794f3c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303630393136303830393536352e6a70673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c327069616a59314e6a67344d7a6c362c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572)
